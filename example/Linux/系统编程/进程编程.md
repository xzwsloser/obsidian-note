# 进程
## 进程和程序以及CPU相关
- 进程与程序:
  - 程序: 死的,只会占用磁盘空间(相当于剧本)
  - 进程: 活的,运行起来的程序,占用内存,`cpu`等系统资源(相当于戏剧)
- 同一个程序可以加载成不同的进程
- 并发与并行:
  - 并发:
    - 在操作系统中,一个时间段中有多个进程都处于已经启动运行到运行完毕之间的状态,但是任意一个时间节点都只有一个程序在执行(**单`CPU`同时执行多个任务**)
  - 并行:
    - **表示多 `CPU` 同时执行多个任务**
- 通过时钟中断来控制进程的调度
- `CPU` 的工作机制:
- 注意一个寄存器的大小就是`4096B` 也就是 `4K`
- `CPU` 与 `MMU(虚拟内存映射单元)`
### 虚拟内存和物理内存的映射关系
- 注意程序不占用资源(只会占用磁盘空间)
- `CPU`一般会被内存分级,把用户空间映射到`3` 级,把内核空间映射成 `0`级,所以从用户空间到内存空间的映射时间消耗比较长
- 虚拟内存映射如图:
- `MMU` 的大小为 `4KB`
### PCB进程控制块
- `PCB`进程控制块是一个结构体,存储在 `/usr/src/linux-headers-6.8.0-40/include/linux
/sched.h` 中 `struct task_struct`
- 重点成员如下:
  - 进程 `id`
  - 进程的状态,就绪,运行,挂起(表示暂时停止(比如执行了 `sleep` 函数)),停止
  -  进程切换时需要保存和恢复的一些`CPU`寄存器
  -  描述虚拟地址空间的信息
  -  占用终端的信息
  -  **当前的工作目录**
  -  **`umask`掩码**
  -  **文件描述描述符号表**
  -  **和信号相关的信息(信号屏蔽字和未决信号集)**
  -  **用户`id`和组`id`**
  -  **会话(`Session`)和进程组**
  -  进程可以使用的资源上限(`Resource limit`)
### 环境变量
- `LD_LIBRARY_LIB` 动态链接器的寻找目录
- `PATH` 可执行程序的路径
- `SHELL` 查看当前使用的 `shell` 解析器
- `TERM` 查看当前使用的终端
- `HOME` 表示家目录
- `env` 查看所有环境变量(环境变量存放在用户空间和内核空间之间,这里还存放着`main`函数的参数)
# 进程控制
## fork函数原理
- 作用: 创建一个子进程
- 函数原型:
```c
pid_t fork(void);
```
- 返回值:
  - 如果成功的话,在父进程中返回子进程的`PID`,并且在子进程中返回 `0`(表示子进程创建成功)
  - 如果创建失败就会返回 `-1`
- `fork`相当于赋值,`fork`之后,子进程和父进程基本一样
![alt text](img/image-2.png)
- `fork`的演示`demo`如下:
```c
#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<stdlib.h>
int main()
{
    printf("before fork1 ...\n");
    printf("before fork2 ...\n");
    printf("before fork3 ...\n");
    printf("before fork4 ...\n");
    pid_t pid = fork();
    if(pid == -1)
    {
        perror("fork error!!!\n");
        exit(1);
    } else if(pid == 0) {
        printf("child is created ... \n");
    } else if (pid > 0){
        printf("my child pid is %d \n" , pid);
    }
    printf("after fork1 ... \n");
    printf("after fork2 ... \n");
    printf("after fork3 ... \n");
    printf("after fork4 ... \n");
}
```
- 执行结果如下:
```shell
before fork1 ...
before fork2 ...
before fork3 ...
before fork4 ...
my child pid is 16048 
after fork1 ... 
after fork2 ... 
after fork3 ... 
after fork4 ... 
child is created ... 
after fork1 ... 
after fork2 ... 
after fork3 ... 
after fork4 ... 
```
- 可见,子进程的代码和父进程一致,但是`fork`之前的代码没有机会执行,`fork`之后的代码有机会执行,所以就会执行两次后面的操作,并且子进程和父进程的的执行相互独立
## getpid 和 getppid
- `getpid` 用于获取当前进程自己的 `pid`
- `getppid` 用于获取当前进程的父进程的 `pid`
- 演示 `demo`:
```c
#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<stdlib.h>
int main()
{
    printf("before fork1 ...\n");
    pid_t pid = fork();
    if(pid == -1)
    {
        perror("fork error!!!\n");
        exit(1);
    } else if(pid == 0) {
        printf("child is created ... \n");
        printf("I am the child , my pid is %d \n" , getpid());
        printf("my father's pid is %d \n" , getppid());
    } else if (pid > 0){
        printf("my child pid is %d \n" , pid);
        printf("I am the father , my pid is %d \n" , getpid());
        printf("and my father's pid is %d \n" , getppid());
    }
    printf("after fork1 ... \n");
}
```
- 父进程的父进程就是 `bash`
## 循环创建子进程
- 如果利用如下代码循环创建多个子进程:
```c
#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<stdlib.h>
int main()
{
    // 循环创建 n 个子进程
    for(int i = 0 ; i < 3 ; i ++){
        int pid = fork();
        if(pid == 0){
            // 表示子进程
            printf("我是第 %d 个子进程,我的pid为: %d  \n", i + 1 , getpid());
        }
    }
}
```
- 但是最后结果创建了 `7` 个子进程,这是由于 `fork`之后,之后的循环代码,子进程仍然会继续调用余下的代码,调用图如下:
![alt text](img/image-3.png)
- 可以让父进程执行外之后退出,并且不再创建子进程了,所以演示代码如下:
```c
#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<stdlib.h>
int main()
{
    // 循环创建 n 个子进程
    for(int i = 0 ; i < 5 ; i ++){
        int pid = fork();
        if(pid == 0){
            // 表示子进程
            printf("我是第 %d 个子进程,我的pid为: %d  \n", i + 1 , getpid());
            break;  // 注意需要退出,此时子进程就需要退出
        }
    }
}
```
- 但是可能出现如下问题:
```text
我是第 2 个子进程,我的pid为: 38367  
我是第 1 个子进程,我的pid为: 38366  
我是第 3 个子进程,我的pid为: 38368  
我是第 5 个子进程,我的pid为: 38370  
我是第 4 个子进程,我的pid为: 38369  
```
- 这是由于虽然每一个子进程被 `fork` 出来的顺序是按照顺序的,但是他们都会抢占 `CPU` 的执行权,所以首先抢占到 `CPU` 执行的进程就会执行打印的代码
- 也可以使用 `sleep` 函数完成礼让的作用:
```c
#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<stdlib.h>
int main()
{
    int i = 0;
    // 循环创建 n 个子进程
    for(i = 0 ; i < 5 ; i ++){
        if(fork() == 0){
            break;
        }
    }
    if(i == 5){
        sleep(5);
        printf("I am the parent!!! \n");
    } else {
        sleep(i);
        printf("I am the %d th child \n",i + 1);
    }
}
```
## 进程共享
- 刚刚 `fork` 之后,父子进程的资源如下:
  - 父子进程相同之处: 全局变量,`data`,`.text`(代码段),栈,堆区,环境变量,用户`ID`,宿主目录,进程工作目录,信号处理方式都相同
  - 父子进程不同之处: 进程`ID` `fork`返回值 父进程 `ID` 进程运行时间 闹钟(定时器) 未决信号集
- 但是并不是子进程完全赋值父进程的用户空间,父子进程之间遵循着**读时共享,写时复制**的原则,这样设计,无论子进程和父进程执行各种操作都可以节约空间
- 测试`demo`如下:  
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
int var = 100; // 全局变量
int main()
{
    int pid = fork();
    if(pid == -1){
        perror("fork failed!\n");
    } else if(pid == 0){
        var = 200;
        printf("I am child , my pid is %d , my father's pid is %d , var is %d  \n" , getpid() , getppid() , var);

    } else if(pid > 0){
        var = 300;
        printf("I am the father , my pid is % d , var is %d \n" , getpid() , var);
    }
}
```
### 父子进程共享
- 父子进程共享:
  - **文件描述符**
  - **`mmap`映射区域**
- 共享遵循读时共享,写时复制(所以并不是完全共享全局变量)
- 但是父子进程的执行时机依赖于父进程的调度算法
## 父子进程 gdb 调试
- 主要是两个命令:
  - `set follow-fork-mode child` 命令设置 `gdb` 在 `fork` 之后跟踪子进程
  - `set follow-fork-mode parent` 设置跟踪父进程
- 注意一定需要在 `fork` 函数之前执行
## exec 函数族
- 作用: 让子进程和父进程执行程序
- `exec`函数族中的函数如下:
```c
       int execl(const char *pathname, const char *arg, ...
                       /*, (char *) NULL */);
       int execlp(const char *file, const char *arg, ...
                       /*, (char *) NULL */);
       int execle(const char *pathname, const char *arg, ...
                       /*, (char *) NULL, char *const envp[] */);
       int execv(const char *pathname, char *const argv[]);
       int execvp(const char *file, char *const argv[]);
       int execvpe(const char *file, char *const argv[], char *const envp[]);
```
- `exec`函数族执行的过程:
  - 当父进程在 `fork` 之后调用了 `exec` 函数,那么子进程在调用到 `exec` 函数之后,就不会在接着执行接下来的代码了,而是执行 `exec` 指定的任务
- 但是执行任务的子进程还没有改变
![alt text](img/image-4.png)
### execl 和 execlp 函数
#### execlp函数
- 作用: 加载一个进程,借助`PATH`环境变量
- 函数原型:
```c
int execlp(const char *file, const char *arg, ...
                       /*, (char *) NULL */);
```
- 该函数一般用于调用系统函数,比如 `ls` `date` `cp` `cat` 等命令
- 参数:
  - `file` 可执行程序文件名称
  - `arg` 表示选项
- 注意最后一定需要加上一个 `NULL` 作为一个哨兵,表示结束
- 但是注意参数从 `arg0` 开始计算,并且 `arg0` 就是命令名称本身
- 一个小的细节(`ls -lh`) 表示显示单位并且使用长列表的方式显示文件列表
- 调用 `execlp` 方法执行系统的函数方式如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
int main()
{
    // 子进程使用 exelp 调用系统函数
    int pid = fork();
    if(pid == -1){
        perror("fork child failed !!! \n");
    } else if (pid == 0) {
        printf("this is child \n");
        // execlp("ls" , "ls" , "-l" , "-h" , NULL);
        execlp("date" , "date" , NULL);
        printf("child finished !!! \n");
    } else {
        sleep(1);
        printf("I am the parent !!! \n");
    }
}
```
#### execl 函数
- 作用: 可以执行第三方的程序,比如自己写的程序,之后的参数基本和 `execlp` 一致
- 设置知道系统函数的路径之后,可以调用系统函数
- 演示`demo`如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
int main()
{
    int pid = fork();
    if(pid == -1){
        perror("fork failed!!!");
        exit(1);
    } else if (pid == 0){
        printf("I am the child !!! \n");
        // execl("./create_loop_fork" , "./create_loop_fork",NULL);
        // 执行系统的命令
        execl("/usr/bin/ls" , "ls" , "-l" , "-h" , NULL);
        printf("child finshed !!! \n");  // 没有了
    } else {
        sleep(1);
        printf("I am the father !!! \n");  
    }
}
```
- 一个小的案例: 把 `ps` 的内容输入到文件中,注意利用 `dup2` 进行重定向输出
```c
#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<stdlib.h>
int main()
{
    // 利用 ps 命令把进程信息写入到文件中
    int pid = fork();
    if(pid == -1){
        perror("fork failed !!!");
        exit(1);
    } else if (pid == 0){
        // 1. 首先创建文件
        int fd = open("./out" , O_CREAT | O_RDWR | O_TRUNC , 0644);
        // 2. 重定向
        int new_fd = dup2(fd , STDOUT_FILENO);  // 表示把标准输出重定向到 fd 中
        // 3. 调用 ps 命令
        execlp("ps" , "ps" , "aux",NULL);
    } else {
        sleep(1);
        printf("I am the father !!! \n");
    }
}
```
#### 其他函数
- `execvp` 函数: 作用基本和 `execl` 基本一样,唯一的不同就是第二个参数是一个数组不是可变参数
- `exec` 函数族的特点:
  - 只有错误才会返回 `-1`
- 所以一般就在 `exec` 后面调用 `perror` 函数和 `exit`函数
- `exec` 函数各种后缀的含义:
  - `l(list)`: 命令行参数列表
  - `p(path)`: 搜索变量的时候使用 `path`变量
  - `v(vector)`: 使用命令行参数数组
  - `e(environment)`: 使用环境变量数组,不使用进程原有的环境变量,设置新加载程序运行时的环境变量
- 六种函数之间的关系,注意只有`exece`是系统调用,其他的都是封装了`exece`:
![alt text](img/Screenshot_20240825_215832_tv.danmaku.bilibilihd.jpg)
## 回收子进程
### 孤儿进程
- 孤儿进程: 父进程先于子进程结束,则子进程成为孤儿进程,子进程的父进程成为 `init` 进程,成为`init` 进程领养孤儿进程(相当于进程孤儿院)
- `ps ajx` 用于查看子进程的父进程
- 代码演示如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
int main()
{
    // 演示孤儿进程
    int pid = fork();
    if(pid == -1){
        perror("fork failed !!! \n");
        exit(1);
    } else if(pid == 0){
        while(1){
            printf("I am the child , my pid is %d , ppid is %d \n" , getpid() , getppid());
            sleep(1);
        }
    } else if(pid > 0){
        printf("I am the father , my pid is %d \n" , getpid());
        sleep(5);
    }
}
```
### 僵尸进程
- 僵尸进程: 进程停止,父进程尚未回收,子进程残留资源(`PCB`)存放在内核中,变成僵尸进程(`Zombie`)进程,理论上来说,基本所有进程都会经历僵尸进程的状态,其实回收的就是`PCB`,其中会记录子进程结束的原因
- 处理僵尸进程的方式: 将它的父进程杀死,让子进程变成孤儿进程从而被回收
- 代码演示如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>
#include<unistd.h>
int main()
{
    int pid = fork();
    if(pid == -1){
        perror("fork failed !!! \n");
        exit(1);
    } else if (pid == 0){
        printf("I am the child , my pid is %d , my ppid is %d \n" , getpid() ,getppid());
        sleep(5);
    } else if(pid > 0){
        while(1){
            printf("I am the father , my pid is %d , my son's pid is %d \n" , getpid() , pid);
            sleep(1);
        }

    }
}
```
### wait 函数
- 作用: 用于回收子进程
- 原理: 可以根据子进程残留的 `PCB` 进程块获取到子进程的信息,从而回收子进程
- 父进程调用`wait`函数可以回收子进程终止信息,该函数有三个状态:
  - 阻塞等待子进程退出
  - 回收子进程残留资源
  - 获取子进程结束状态(退出原因)
- 头文件: `<sys/wait.h>`
- 函数原型:
```c
  pid_t wait(int *_Nullable wstatus);
       pid_t waitpid(pid_t pid, int *_Nullable wstatus, int options);

       int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
                       /* This is the glibc and POSIX interface; see
                          NOTES for information on the raw system call. */
```
- 参数:
  - `status` 表示子进程的状态,可以传入一个整形参数的地址用于接受即可(并且可以利用宏函数来判断子进程退出原因)
- 返回值: 回收失败就会返回 `-1`
- 演示`demo`如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/wait.h>
int main()
{
    int pid = fork();
    int status;
    int wpid;
    if(pid == -1){
        perror("fork failed !!! \n");
        exit(1);
    } else if(pid == 0) {
        printf("I am the child , my pid is %d , my parent's pid is %d \n",getpid(),getppid());
        sleep(5);
    } else if(pid > 0){
        wpid = wait(&status);
        if(wpid == -1){
            perror("failed to resouce the child !!! \n");
            exit(1);
        } 
        printf("wid = %d \n" , wpid);
        printf("successfully resouce the child !!! \n");
    }
}
```
#### 获取子进程退出值和异常终止信号
- 一般来说都是由于信号才会时的进程终止,比如 `kill -l` 可以查看所有信号量
- 利用各种宏定义函数可以判断子进程突出原因:
  - `WIFEXITED` 返回`true` 表示子进程正常退出,如果使用`exit`函数默认返回 `1`
  - `WEXITSTATUS` 上面一个返回 `true` 的情况下,返回子进程退出的返回值(`return`)
  - `WIFSIGNALED` 如果子进程被信号终止,就会返回 `true`
  - `WTERMSIG` 返回子进程被终止的信号
  - `WIFSTOPPED` 判断进程是否暂停
  - `WSTOPIG` 获取暂停子进程的信号
  - `WIFCOUNTINE` 获取让子进程继续执行的信号
- 演示`demo`:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/wait.h>
int main()
{
    int pid = fork();
    int status;
    int wpid;
    if(pid == -1){
        perror("fork failed !!! \n");
        exit(3);  // 如果调用 exit函数默认返回 1
    } else if(pid == 0) {
        printf("I am the child , my pid is %d , my parent's pid is %d \n",getpid(),getppid());
        sleep(20);
        exit(10);
    } else if(pid > 0){
        wpid = wait(&status);  // 如果子进程没有终止,父进程就会阻塞
        if(wpid == -1){
            perror("failed to resouce the child !!! \n");
            exit(1);
        } 

        if(WIFEXITED(status)){  // 正常退出
            int res = WEXITSTATUS(status); // 获取退出状态
            printf("child return the number: %d \n" , res);
        }
        if(WIFSIGNALED(status)) {  // 表示异常终止,说明子进程被信号终止
            // 查看信号
            printf("child killed with signale: %d \n" , WTERMSIG(status));
        }   
        printf("wid = %d \n" , wpid);
        printf("successfully resouce the child !!! \n");
    }
}
```
### waitpid函数
- 作用: 回收子进程
- 头文件:
  - `<sys/wait.h>`
- 函数原型:
```c
pid_t waitpid(pid_t pid, int *_Nullable wstatus, int options);
```
- 参数:
  - `pid` 需要回收子进程的 `pid`:
    - `>0` 指定`ID`的子进程
    - `-1` 回收任意子进程(相当于`wait`)
    - `0`  回收和当前调用`waitpid`一个组的所有子进程
    - `<-1` 回收指定进程组里面的任意子进程(组号等于绝对值)
  - `wstatus` 记录子进程的状态
  - `options` 可以设置函数的属性,比如可以设置函数的属性为非阻塞的形式
- 返回值:
  - 成功回收返回子进程 `id`
  - 函数调用的时候,指定了`WNOHANG`,并且没有子进程结束
  - 失败返回 `-1` 和 `errorno`
- 细节: 无论是`wait`还是`waitpid`调用,只是可以回收一个子进程
- 演示`demo`如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/wait.h>
int main()
{
    int pid,wait_pid;
    int target;
    int i  ;
    for(i = 0 ; i < 5 ; i ++){
        pid = fork();
        if(i == 2 && pid > 0){
            target = pid;
        }
        if(pid == 0){
            printf("I am the child , my pid is %d \n" , getpid());
            break;
        }
    }
    // 开始回收
    if(i == 5){
        sleep(5);
        // 1. 回收任意的 pid
        // wait_pid = waitpid(-1 , NULL , WNOHANG); // 表示不会阻塞
        // 此时没有回收的进程成为孤儿进程被回收
        // 2. 指定 pide
        wait_pid = waitpid(target , NULL , 0);
        printf("wait_pid = %d \n" , wait_pid);
        printf("I am parent , my pid is %d \n" , pid);
    } else {
        printf("I am the %d th child , my pid is %d \n" , i + 1 , getpid());
    }
}
```
- 进程编程的时候,一定需要注意父子进程进行变量共享的时候,遵循读是共享,写时复制的原则
- 总结: 
  - `wait` 和 `waitpid` 的区别: `wait`只可以阻塞的等待并且不可以指定具体需要回收那一个子进程,`waitpid`可以指定是否阻塞并且需要回收那一个子进程
  - 共同之处: 只可以回收一个子进程,不可以回收多个子进程
### 利用 waitpid 回收多个子进程
- 需要使用循环回收多个子进程
- 演示`demo`如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<sys/wait.h>
#include<unistd.h>
#include<fcntl.h>
int main()
{
    int i ;
    for(i = 0 ; i < 5 ; i ++){
        if(fork() == 0){
            break;
        }
    }
    if(i == 5){
        // 回收
        // 1. 阻塞的方式回收
        printf("I am the father , I am gonna to resource my child \n");
        int wpid;
        // while((wpid = waitpid(-1 , NULL , 0)) != -1){
        //     printf("Successfully resource child, pid: %d \n" , wpid);
        // }
        // 2. 非阻塞的方式回收
        while((wpid = waitpid(-1 , NULL , WNOHANG)) != -1){
            if(wpid == -1){
                break;
            } else if(wpid == 0){
                sleep(1);
            } else if(wpid > 0){
                printf("Successfully resource child, pid: %d \n" , wpid);
            }
        }
    } else {
        printf("I am the %d th child , my pid is %d \n" , i + 1 , getpid());
    }
}
```
- 相当于: `waitpid(-1 , &status , 0) == wait(&status)`
### 综合案例
- 要求父进程`fork` `3` 个子进程,三个子进程一个调用 `ps` 命令,一个调用自定义程序 `1`(正常) , 另外一个调用自定义程序 `2`(发生段错误),父进程使用 `waitpid` 对于子进程进行回收
- 演示`demo`如下:
```c
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>
#include<fcntl.h>
int main()
{
    int i ;
    int status;
    for(i = 0 ; i < 3 ; i ++){
        if(fork() == 0){
            break;
        }
    }
    // 开始调用
    if(i == 0){
        printf("I am the %d child , my pid is %d \n" , i + 1 , getpid());
        // 调用 ps 命令
        int fd = open("./out" , O_CREAT | O_TRUNC | O_RDWR , 0644);
        // 重定向
        int new_fd = dup2(fd , STDOUT_FILENO);
        // ps 命令
        execlp("ps" , "ps" , "aux" , NULL);
        // 无法关闭文件, 利用父进程
    } else if(i == 1) {
        // 调用正常的程序
        printf("I am the %d child , my pid is %d \n" , i + 1 , getpid());
        execlp("./test_demo1" , "./test_demo1" ,NULL);
    } else if(i == 2) {
        // 调用异常程序
        printf("I am the %d child , my pid is %d \n" , i + 1 , getpid());
        execlp("./test_demo2" , "./test_demo2" , NULL);
    } else if (i == 3) {
        printf("I am the father !!! \n");
        // 开始进行回收
        int wpid;
        while((wpid = waitpid(-1 , &status , 0)) != -1){
            if(wpid > 0){
                // 首先判断状态
                if(WIFEXITED(status)){
                    // 表示正常退出
                    printf("返回值为: %d \n" , WEXITSTATUS(status));
                } 
                if(WIFSIGNALED(status)){
                    printf("异常终止,终止信号为: %d \n" , WTERMSIG(status));
                }
                printf("Successfully resource the child whose pid is %d \n" , wpid);
            }
        }
    }
}
```
# 进程间通信方式
- 由于父子进程之间基本隔离,所以如果需要进行数据的相互交换,那就需要进行进程之间的通信,进程之间通信(`IPC`)
- 原理:
  - 父子进程公用一个内核空间(当然这是物理上的),其实父子进程之间的桥梁就是内核中的一个缓冲区(默认大小为`4096B(4K)`)
- 进程中通信的方式(最常用的四种):
  - 管道(使用最简单)
  - 信号(开销最小)
  - 共享映射区(无血缘关系)
  - 本地套接字(最稳定)
## 匿名管道(pipe)
### 管道的性质
- 管道是一种最基本的`IPC`机制,作用于有血缘关系的进程之间,完成数据的传递,调用 `pipe` 系统函数就可以创建一个管道,有如下性质:
  - 本质就是一个伪文件(处理普通文件,目录,软链接等,其他的都是伪文件,不会占用磁盘空间)
  - 有两个文件描述符引用,一个表示读端,另外一个表示写端
  - 规定数据从管道的写端流入管道,从读端流出管道
- 管道的原理: 管道实际上是内核使用循环队列的形式实现出来的,借助内核缓冲区`(4K)`实现
- 管道的局限性:
  - 数据不可以自己写入,自己读取
  - 管道中数据不可以重复读取,一旦读走,管道中就不再存在了
  - 采用(双向)半双工通信方式,数据只可以在单方向上流动
  - 只能在有公共祖先的进程之间使用管道
- 单工通信: 比如遥控器
- 半双工通信: 比如对讲机,每一次只有一个端可以传递信息
- 全双工通信: 相当与打电话(`WebSocket`)
### pipe函数
- 作用: 创建一个管道,并且打开管道
- 函数原型:
```c
int pipe(int pipefd[2]);
```
- 参数:
  - `pipefd[0]`  表示读端
  - `pipedf[1]`  表示写端
- 返回值：
  - 成功返回 `0`  失败返回 `-1`
- 相当于传递着一个数组之后,就可以把着一个数组中填充读端和写端,父子进程都可以获取到管道的两端
- 最后一定需要注意关闭读端或者写端,调用 `close` 函数,一个写的时候,必须关闭另外一个端
- 注意利用 `read` 读取之后,可以使用 `write`写入到 `STDOUT` 中
- 管道演示`demo`:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
#include<string.h>
int main()
{
    int pipefd[2];
    // 1. 创建管道
    int res = pipe(pipefd);
    char buf[1024];  // 这样可以节约空间
    if(res == -1){
        perror("create pipe failed!!! \n");
        exit(1);
    }
    // 2. 利用 fork调用子进程
    int pid = fork();
    if(pid == -1){
        perror("fork the child failed !!! \n");
        exit(1);
    } else if(pid == 0) {
        // 表示子进程
        // 读取数据
        close(pipefd[1]);  // 关闭写端
        int ret = read(pipefd[0] , buf , 1024);
        if(ret == -1){
            perror("read from pipe failed !!! \n");
            exit(1);
        } 
        write(STDOUT_FILENO , buf , ret);
    } else if(pid > 0) {
        // 表示父进程
        // 向管道中写入数据
        close(pipefd[0]);  // 关闭读端
        char* str = "hello pipe\n";
        write(pipefd[1] , str , strlen(str));
        // 关闭读端
        sleep(1);
        close(pipefd[1]);
    }

}
```
### 管道的读写行为
- 读管道:
  - 如果管道中有数据,`read`返回时机读到的字节数
  - 如果管道中没有数据:
    - 管道写端被全部关闭,`read`返回`0`(就像读到了文件结尾)
    - 管道写端没有被全部关闭,`read`阻塞等待(不久的将来可能会有数据到达,此时会让出`cpu`)
- 写管道:
  - 如果管道的读端被完全关闭,进程异常终止(也有可能捕捉`SIGPIPE`信号,使得进程不终止)
  - 管道读端没有全部关闭:
    - 管道已满,`write`阻塞
    - 管道没有满,`write`将数据写入,并且返回时机写入的字节数量
#### 案例
- 实现父子之间进程的通信,实现`ls | wc -l`,假设父进程实现`ls`,子进程实现`wc`
- 注意几个细节:
  - `ls` 默认把信息输入到 `stdout` 所以需要让 `stdout` 指向 `pipefd[1]`
  - `wc` 默认从 `stdin` 中读取, 所以需要让 `stdin`指向 `pipefd[0]`
- 实现`demo`如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
int main(int argc , char** argv)
{
    int pipefd[2];
    int ret = pipe(pipefd);
    if(ret == -1){
        perror("create pipe failed !!! \n");
        exit(1);
    }
    int pid = fork();
    if(pid == -1){
        perror("fork child failed !!! \n");
        exit(1);
    } else if(pid == 0) {
        // 实现 wc
        close(pipefd[1]);
        // 重定向
        int ret = dup2(pipefd[0] , STDIN_FILENO);  // wc -l 从输入中读取,其实就是从pipe[0]中读取
        if(ret == -1){
            perror("dup2 failed !!! \n");
            exit(1);
        }
        execlp("wc" , "wc" , "-l" , NULL);

    } else if(pid > 0) {
        char* target;
        if(argv[1] == NULL){
            target = ".";
        } else {
            target = argv[1];
        }
        // 实现 ls 命令
        // 1. 重定向
        int newfd = dup2(pipefd[1] , STDOUT_FILENO);
        if(newfd == -1){
            perror("dup2 error !");
            exit(1);
        }
        // 2. 调用
        close(pipefd[0]);
        execlp("ls" , "ls" , target , NULL);
    }

}
```
### 兄弟进程之间的通信
- 利用兄弟之间进程通信实现 `ls | wc -l`
- 注意对于一个管道,一定需要形成一个消息传递链,如下代码中如果没有在父进程中加上关闭写端和读端的操作,就会造成如下结果:
![alt text](img/image-5.png)
- 没有达到管道的回路状态
- 正确的代码如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/wait.h>
int main()
{
    // 实现兄弟之间进程的通信
    int i ;
    int pipefd[2];
    int ret = pipe(pipefd);
    if(ret == -1){
        perror("create pipe failed !!! \n");
        exit(1);
    }
    for(i = 0 ; i < 2 ; i ++){
        if(fork() == 0) {
            break;
        }
    }

    if(i == 0) {
        // 第一个进程
        // 实现 ls
        printf("I am going to do ls , my pid is %d \n", getpid());
        close(pipefd[0]);
        int newfd = dup2(pipefd[1] , STDOUT_FILENO);
        if(newfd == -1 ) {
            perror("dup2 failed!!! \n");
            exit(1);
        }   
        // 开始执行操作
        execlp("ls" , "ls" , NULL);
        sleep(5);
    } else if (i == 1) {
        // 第二个进程
        // 实现 wc 操作
        printf("I am going to do wc , my pid is %d \n", getpid());
        close(pipefd[1]);
        int newfd = dup2(pipefd[0] , STDIN_FILENO);
        if(newfd == -1){
            perror("dup2 failed !!! \n");
            exit(1);
        }
        // 开始执行操作
        execlp("wc" , "wc" , "-l" , NULL);
    } else if(i == 2){
        // 父亲进程
        // 进行进程的回收
        close(pipefd[1]);
        close(pipefd[0]);
        printf("I am the parent , going to resource my child !!! \n");
        int wpid;
        // sleep(10);
        while((wpid = waitpid(-1 , NULL , 0)) != -1){
            if(wpid != -1){
                printf("Successfully resource my child whose pid is %d \n" , wpid);
            }
        }
    }
}
```
### 多个读写端操作和管道缓冲区的大小设置
- 结论: 一个`pipe`可以有多个写端,一个读端,但是最好不用这样用,这样难以进行定点之间信息的传递,但是需要经可能避免这一种情况,并且无法控制消息的顺序
- 使用 `ulimit -a` 可以查询缓冲区的大小,管道的缓冲区大小为 `4K`
- 还可以使用 `fpathconf` 查询管道大小,函数原型如下:
```c
long fpathconf(int fd, int name);
```
- `name` 可以传入多种宏定义,用于判断查询类型
### 管道的优缺点
- 优点: 简单,相比于信号,套接字实现进程间通信,简单很多
- 缺点:
  - 只可以单向通信,双向通信需要建立两个管道
  - 之可以用于父子,兄弟进程(有共同祖先)间通信,该问题之后使用 `fifo` 有名管道解决
## 具名管道(fifo)
- 基本原理和`pipe`差不多: 都是利用在内核空间建立缓冲区的方式实现管道的,不同之处在于`fifo`给管道起了名字
### 创建方式
- 创建方式:
  - 命令: `mkfifo 管道名`
  - 库函数: `mkfifo`
- `mkfifo`函数原型如下:
```c
int mkfifo(const char *pathname, mode_t mode);
```
- 头文件:
  - `<sys/types.h>`
  - `<sys/stat.h>`
- 参数:
  - `pathname` 路径
  - `mode` 类似于 `open` 选项(权限值)
- 返回值:
  - 成功返回 `0`  失败范围 `-1`
- 创建管道的`fifo`如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
int main()
{
    // 创建管道
    int ret = mkfifo("./myfifo" , 0644);
    if(ret == -1){
        perror("create fifo failed !!! \n");
        exit(1);
    }
}
```
### 利用fifo实现非血缘关系进程之间通信
- 把 `fifo` 看成一个文件:
  - 写端: 打开文件(只是写入方式) , 利用 `write` 写入数据
  - 读端: 读取文件(只是读方式) , 利用 `read` 读文件
-  可以实现一个写端多个读端和多个读端一个写端
- 读的方式如下:
```c
#include<stdlib.h>
#include<string.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<unistd.h>
#include<fcntl.h>
int main(int argc , char** argv)
{
    // 演示从管道中读取数据
    if(argc < 2){
        perror("请输入管道名称 \n");
        exit(1);
    }
    int fd = open(argv[1] , O_RDONLY);
    // 不断读取数据
    char buf[1024];
    int n = 0;
    while((n = read(fd , buf , 1024)) != 0) {
        if(n == -1){
            perror("read from fifo failed !!! \n");
            exit(1);
        }
        write(STDOUT_FILENO , buf , n);
        sleep(1);
    }
}

```
- 写的方式如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<unistd.h>
#include<fcntl.h>
int main(int argc , char** argv)
{
    // 向管道中写入数据
    if(argc < 2){
        perror("请输入管道名称 !!! \n");
        exit(1);
    }
    // 打开
    int fd = open(argv[1] , O_WRONLY);
    // 开始写入数据
    char buf[1024];
    int i = 1;
    while(1){
        sprintf(buf , "hello fifo %d \n" , i);
        int ret = write(fd , buf , strlen(buf));
        if(ret == -1){
            perror("write into fifo failed !!! \n");
            exit(1);
        }
        i ++;
        sleep(1);
    }
}
```
### 文件用于进程之间的通信
- 使用文件也可以完成`IPC`,理论依据就是`fork`之后,父子共享文件描述符,所以父子进程之前,可以通过同一个文件描述符号找到同一个文件，一个进行读操作,另外一个进行写操作即可
- 对于不同的进程,由于不同的进程的 `PCB` 不同,所以肯能文件描述符号不同,但是不同的文件描述符号还是指向了同一个文件,所以还是可以对于一个文件进行读操作,另外一个文件进行写操作,所以没有血缘关系的进程也可以打开同一个文件进行通信
## 存储映射 I/O
- 存储映射: 使得一个磁盘与存储空间爱你的一个缓冲区向映射(其实就是磁盘和内存的映射),并且进入内存之后就可以得到地址,利用地址就可以使用指针进行 `IO` 操作,而不依赖与 `read` 和 `write` 函数对于文件进行操作
- 映射方式如下:
![alt text](img/Screenshot_20240826_161245_tv.danmaku.bilibilihd.jpg)
### mmap函数
- 作用: 完成存储映射
- 头文件: `<sys/mmap.h>`
- 函数原型:
```c
void *mmap(void addr[.length], size_t length, int prot, int flags,
                  int fd, off_t offset);
```
- 参数: 
  - `addr`  指定映射区域的首地址(通常可以传递 `NULL` 表示让系统自动分配)
  - `length` 表示共享内存映射区域的大小 (`<=` 文件大小)
  - `prot` 表示共享内存区域的读写属性:
    - `PROT_READ`  只读
    - `PROT_WRITE` 只写
    - `PROT_READ | PROT_WRITE` 读写
  - `flags` 标记共性属性(`MAP_SHARED` `MAP_PRIVATE`(对于内存的修改不会同步到磁盘))
  - `fd`  用于创建共享内存映射区域的文件的文件描述符号
  - `offset` 偏移位置(相当于磁盘中的文件)(必须是 `4K` 的整数倍)(`0` 表示映射文件的全部)
- 返回值(泛型指针):
  - 成功: 成功创建的内存映射区域的首地址
  - 失败: `MAP_FAILED` 就是 `(void*)(-1)` 并且设置 `errorno`
#### 利用 mmap 建立映射区域
- 注意使用 `munmap` 函数进行映射空间的释放
- 函数原型:
```c
int munmap(void addr[.length], size_t length);
```
- 注意拓展文件的方式:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/mman.h>
#include<fcntl.h>
#include<string.h>
void sys_exit(const char* msg)
{
    perror(msg);
    exit(1);
}
int main()
{
    // 利用 mmap 创建内存映射
    // 1. 首先获取文件
    int fd = open("temp.txt" , O_CREAT | O_TRUNC | O_RDWR , 0644);
    if(fd == -1){
        sys_exit("create file failed !!!");
    }
    // 2. 对于文件进行扩容操作
    // 2.1 第一种方式,使用 lseek
    // lseek(fd , 10 , SEEK_END);
    // write(fd , "\0" , 1);
    // 2.2 利用 ftrancate 函数
    ftruncate(fd , 20);  // 扩容函数
    // 3. 获取文件大小
    int len = lseek(fd , 0 , SEEK_END); // 获取长度
    // 4. 调用 mmap 函数
    char* p = NULL;
    // 相当于自动类型转换
    p = mmap(NULL,len,  PROT_READ | PROT_WRITE , MAP_SHARED , fd , 0);
    if(p == MAP_FAILED){
        sys_exit("mmap failed!!!");
    }
    strcpy(p , "hello mmap!!!\n");
    // 5. 释放映射区域
    int ret = munmap(p , len);
    if(ret == -1){
        sys_exit("munmap failed !!!");
    }
}
```
#### mmap使用注释事项
- 用于创建映射区域的大小为 `0` , 实际指定非 `0` 大小创建映射区域,会出现 总线错误(或者偏移大于文件大小)
- 用于创建映射区的文件大小为 `0` , 实指定 `0` 大小创建映射区,出 无效参数错误
- 用于创建文件读写属性为只读,映射区域属性为读写(必须读写或者前者大于后者),出 无效参数错误
- 使用`ftruncate`扩展文件,需要向文件中写入数据,所以需要把文件的权限设置为可写
- 创建映射区域需要`read`权限(创建的时候需要从文件中的读出信息来建立映射区域),`mmap`的读写权限必须小于等于文件的 `open` 权限
- 文件描述符号`fd` 在创建文件映射区域完毕之后就可以关闭了,之后直接操作地址即可
- `offset` 必须是 `4096`的整数倍,和`MMU`相关,注意`MMU`映射的最小长度就是 `4K`
- 对于申请的内存,不可以越界访问
- `mumap`释放的地址必须是`mmap`创建得到的地址,就是不可以改变指针的位置
- 一定需要检测`mmap` 操作是否成功
- 映射区域访问权限为`MAP_PRIVATE` 表示设置私有权限,就会导致在内存中对于文件的操作不会反映到磁盘上
- 设置`prot`权限为 `MAP_PRIVATE`的时候,只需要`open`的时候有读权限,用于创建映射区域就可以了,用于创建映射区域即可,原因就是不用同步到磁盘上

- `mmap` 函数的保险调用方式:
  - `open(O_RDWR)`
  - `mmap(NULL , 有效大小 , PROT_READ | PROT_WRITE , MAP_SHARED , fd , 0)`
#### mmap建立父子之间通信
- 为了保证通信可行,所以 `flags` 需要设置为 `MPA_SHARED`(否则就会归父进程私有)
- 首先利用 `mmap` 建立映射区域,之后利用 `fork` 创建子线程
- 父子进程使用`mmap`进行通信:
  - 首先创建映射区域: `open`  `mmap`,指定权限为 `MAP_SHARED`
  - 创建子进程
  - 一个进程读,一个进程写
- 父子进程之间通信的方式如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/mman.h>
#include<unistd.h>
#include<fcntl.h>
void sys_exit(const char* msg)
{
    perror(msg);
    exit(1);
}
int main()
{
    int ret;
    int fd = open("out" , O_CREAT | O_TRUNC | O_RDWR , 0644);
    if(fd == -1){
        sys_exit("open file failed !!! \n");
    }
    // 扩容
    ret = ftruncate(fd , 20);
    if(ret == -1){
        sys_exit("ftruncate failed !!! \n");
    }
    // 获取长度
    int len = lseek(fd , 0 , SEEK_END);
    // 建立内存映射区域
    char* p = mmap(NULL , len , PROT_READ | PROT_WRITE , MAP_SHARED , fd , 0);
    if(p == MAP_FAILED){
        sys_exit("mmap failed !!! \n");
    }
    // 创建子进程
    int pid = fork();
    if(pid == 0){
        // 子进程
        // 发送消息
        strcpy(p , "hello father!");

    } else if (pid > 0){
        // 父进程
        sleep(1);
        write(STDOUT_FILENO , p , strlen(p));
    }

    close(fd);
    ret = munmap(p , len);

    if(ret == -1){
        sys_exit("umap failed !!! \n");
    }
}
```
#### mmap进行非血缘关系进程之间通信
- 注意其实内存中的操作最终会被同步到磁盘,所以和利用文件进行通信类似,但是这一种方式基于内存,操作更快更加便捷
- 好处就是可以传递任意数据类型(包含结构体等信息)
- 注意可以使用 `memcpy` 作内存拷贝(注意不是拼接而是拷贝)(类似于`strcpy`) 
- 函数原型如下:
```c
void *memcpy(void dest[restrict .n], const void src[restrict .n],
                    size_t n);
```
- 写进程代码如下:
```c
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<string.h>
#include<fcntl.h>
#include<sys/mman.h>
void sys_exit(const char* msg);
void sys_exit(const char* msg)
{
    perror(msg);
    exit(1);
}
struct student {
    int age;
    char name[256];
    int id;
};
int main()
{   
    int ret;
    struct student stu = {18 , "xiaoming" , 1};
    int fd = open("out" , O_CREAT | O_TRUNC | O_RDWR , 0644);
    if(fd == -1){
        sys_exit("open file failed !!! \n");
    }
    // 扩容
    ret = ftruncate(fd , sizeof(stu));
    if(ret == -1){
        sys_exit("truncate file failed !!! \n");
    }
    int len = lseek(fd , 0 , SEEK_END);
    
    struct student* p = mmap(NULL , len , PROT_READ | PROT_WRITE , MAP_SHARED , fd , 0);
    if(p == MAP_FAILED){
        sys_exit("mmap failed !!! \n");
    }
    // 写入数据
    
    while(1){
        memcpy(p , &stu , sizeof(stu));
        stu.id ++;
        sleep(1);
    }

}
```

- 读进程如下:
```c
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<string.h>
#include<fcntl.h>
#include<sys/mman.h>
void sys_exit(const char* msg);
void sys_exit(const char* msg)
{
    perror(msg);
    exit(1);
}
struct student {
    int age;
    char name[256];
    int id;
};
int main()
{
    // 打开文件
    int fd = open("out" , O_RDWR);
    if(fd == -1){
        sys_exit("open file failed !!! \n");
    }
    // 读取文件内容
    int len = lseek(fd , 0 , SEEK_END);
    struct student* p = mmap(NULL , len , PROT_READ | PROT_WRITE , MAP_SHARED , fd , 0);
    if(p == MAP_FAILED){
        sys_exit("mmap failed !!! \n");
    }
    close(fd);
    // 开始读取文件
    while(1){
        printf("id = %d , name = %s , age = %d \n" , p-> id , p->name , p -> age);
        sleep(1);
    }
}
```
- 支持一个读端多个写端,一个写端多个读端
- 没有血缘关系进程之间通信:
  - 两个进程同时打开同一个文件,创建映射区
  - 指定`flag` 为`MAP_SHARED`
- 注意没有血缘关系的进程之间通信的两种方式比较:
  - `mmap` 可以多次读
  - `fifo` 只可以一次读
#### mmap匿名映射区
- 删除用于创建映射区的文件删除之后仍然可以创建映射区,所以可以创建匿名映射区
- 此时`fd` 参数可以指定为 `-1`
- 函数的使用方式:
```c
mmap(NULL , 40 , PROT_READ|PROT_WRITE , MAP_SHARED | MAP_ANONYMOUS , -1 , 0);
```
- 但是无法完成非血缘关系进程之间的映射
## 信号
- 信号的特点:
  - 简单
  - 不可以携带大量信息
  - 满足特定条件才可以发送信号
### 信号的机制
- 信号的特质:
  - 信号是软件层面的中断,一旦信号产生,无论程序执行到什么位置,必须停止运行,处理信号,处理结束,在继续执行后续指令
- 所有信号都是由内核发送并且处理的
### 与信号相关的时间和状态
- 产生信号:
  - 按键产生: `Ctrl + C` `Ctrl + Z`
  - 系统调用产生: `kill`  `raise`
  - 软件条件产生: 比如定时器 `alarm`(比如`sleep`)
  - 硬件异常产生, 比如: 非法访问内存(段错误),除`0`,内存对齐错误
  - 命令产生,比如`kill`命令
- 递达(递送到达): 递达并且到达进程
- 未决： 产生和递归之间的状态,主要由于阻塞(屏蔽)导致着一个状态
- 信号的处理方式:
  - 执行默认动作
  - 忽略
  - 捕捉(调用用户处理函数)
- `Linux`内核的进程控制块`PCB`是一个结构体,`task_struct` 除了包含进程`id`, 状态,工作目录,用户`id`,组`id`,文件描述符,还包含了信号相关的信息,主要指的就是阻塞信号集和未决信号集
- 阻塞信号集(信号屏蔽字): 将某些信号加入到集合中,对他们设置屏蔽,当屏蔽x信号之后,在受到该信号,**该信号的处理将推后(**接触屏蔽之后)
- 未决信号集:
  - 信号产生,未绝信号集中描述该信号的位立刻翻转为 `1`,表示信号处于未决状态,当信号被处理,对应的位立刻翻转为 `0`,这一个时刻往往比较短暂
  - 信号产生之后,由于某些原因(主要是由于阻塞)不可以抵达,这一类信号的集合称之为未决信号集,在屏蔽接触之前,信号一直处于未决状态(屏蔽的时候产生)
- 信号都是固定的,未决信号集和信号屏蔽字中都是存储着他各种信号状态(信号种类都是由操作系统规定的)
- 信号处理过程如下:
![alt text](img/image-6.png)
### 常见的信号和信号四要素
- 利用 `kill -l` 查看各种信号
```text
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	
```
- 信号四要素:
  - 编号
  - 名称
  - 事件
  - 默认处理动作
- 利用 `man 7 signal` 可以查看信号的各种特征
- `Linux`常见信号一览表:
- 常见的信号比如: `SIGHUP`  `SIGINT`  `SIGKILL` `SIGQUIT` `SIGBUS`(总线错误) `SIGPE` `SIGUSR1` `SIGSEGV` `SIGUSR2` `SIGPIPE` `SIGALRM` `SIGTERM` `SIGCHLD` `SIGSTOP`
![alt text](img/image-7.png)

- 默认动作:
  - `Term`: 终止进程
  - `lgn`: 忽略信号(默认就是对该信号忽略操作) 
  - `Core`: 终止进程,生成`Core`文件(查验进程死亡原因,用于`gdb`调试)
  - `Stop`: 停止(暂停)进程
  - `Cont`: 继续执行进程
- 但是注意 `9)SIGKILL` 和 `19)SIGSTOP` 不允许忽略或者捕捉,甚至不可以设置未屏蔽
- 只有每一个信号对应的时间发生了,该信号才可以被递达,不可以乱发信号
### kill函数与kill命令
#### kill命令
- 利用 `kill` 命令产生信号: `kill -SIGKILL 进程号` 就是 `kill -信号号码 进程号`
#### kill函数
- 作用: **向某一个进程发送信号**
- 头文件: `<signal.h>`
- 函数原型:
```c
int kill(pid_t pid, int sig);
```
- 参数:
  - `pid` 需要给那一个进程发送信号
    - `pid > 0` 发送信号给默认的进程
    - `pid = 0` 发送信号给调用 `kill` 函数进程属于同一个进程组的所有进程
    - `pid < -1` 取`pid`发送给对应的进程组(进程组号就是 `-pid`)
    - `pid = -1` 发送给进程所有权限发送的系统中的所有进程
  - `sig` 信号编号(宏定义)
- 返回值: 
  - 成功返回 `0`
  - 失败返回 `-1` 设置 `errono`
- 普通用户的基本规则就是: 发送者的实际或者有效用户`ID` == 接受者实际或者有效的用户`ID`
```c
#include<stdio.h>
#include<stdlib.h>
#include<signal.h>
#include<unistd.h>
int main()
{
    int pid = fork();
    if(pid == 0){
        printf("I am child , my pid is %d , my ppid is %d \n" , getpid() , getppid());
        // kill(getppid() , SIGSEGV);  // 表示段错误
        // kill(getppid() , SIGKILL)  表示强制杀死进程
        while(1){
            printf("I am child ! \n");
            sleep(1);
        }
    } else if(pid > 0){
        printf("I am the parent , my pid is %d \n",getpid());
        // while(1){
        //     printf("this is my code !!! \n");
        //     sleep(1);
        // }
        // 进程组 id 其实就是当前进程的id
        // kill(- getppid() , SIGKILL);
    }
}
```
- 循环创建进程并且杀死指定进程:
```c
#include<stdio.h>
#include<stdlib.h>
#include<signal.h>
#include<unistd.h>
#include<string.h>
int main()
{
    // 循环创建5个子进程并且利用 kill 函数杀死任意一个进程
    int target;  // 记录需要杀死的子进程假设就是 第三个
    int i ;
    for(i = 0 ; i < 5 ; i ++){
        int pid = fork();
        if(pid == -1){
            perror("fork failed !!!");
            exit(1);
        }
        if(pid == 0){
            break;
        }
        if(pid > 0 && i == 2){
            target = pid;
        }
    }

    if(i >= 0 && i <= 4){
        // 子进程
        printf("I am the %d th child , my pid is %d \n",i + 1 , getpid());
        sleep(10);
    } else if(i == 5){
        sleep(2);
        int ret = kill(target , SIGKILL);
        if(ret == -1){
            perror("kill failed !!!");
            exit(1);
        }
        printf("ret = %d \n" , ret);
    }

}
```
### alarm函数
- 作用: 设置定时器(闹钟),指定`seconds`之后,内核会给当前进程发送`14)SIGALRM`信号,进程受到信号之后,默认动作终止,每一个进程都有且仅有唯一一个定时器
- 头文件: `<unistd.h>`
- 函数原型:
```c
unsigned int alarm(unsigned int seconds);
```
- 参数: 表示设置的秒数
- 返回值: `0` 或者剩余的秒数(重置定时器之前的剩余秒数),没有失败的情况
- 比如以下过程中: `alarm(5) -- 3 sec -- alarm(4) -- 5sec -- alarm(5) -- alarm(0)`
- 此时 `alarm(4)` 返回 `5 - 3 = 2`  `alarm(5)` 由于上一次定时器超过时间返回 `0` `alarm(0)` 返回上一次定时器的剩余时间 `5`
- `alarm(0)`  用于清除定时器
- 闹钟时间到的时候,就会向程序发送信号表示闹钟结束,会终止进程
- 可以使用 `time` 命令,程序运行的瓶颈在于`IO`,优化程序,首选优化 `IO`
- 实际执行时间 = 系统时间 + 用户时间 + 等待时间
### setitimer函数
- 函数功能: 设置定时器,可以替代 `alarm`函数精度微秒可以设置定时周期
- 头文件: `<sys/timer.h>`
- 函数原型:
```c
int setitimer(int which, const struct itimerval *restrict new_value,
                     struct itimerval *_Nullable restrict old_value);
```
- 参数: 
  - `which`:
    - 自然定时: `ITIMER_REAL -> 14) SLGLARM` 计算自然时间
    - 虚拟空间计时(用户空间): `ITIMER_VIRTUAL -> 26) SIGVTALRM` 只是计算进程占用 `CPU` 的时间
    - 运行时计时(用户+内核) : `ITIMER_PROF -> 27)SIGPROF` 只计算占用 `cpu` 和执行系统调用的时间
  - `new_value` 新的定时时间
  - `old_value` 传出参数,表示剩余的时间,是一个传出参数
- 返回值:
  - 成功返回 `0`
  - 失败返回 `-1` 设置 `errorno`
- `struct itimerval` 类型的定义如下:
```c
   struct itimerval {
               struct timeval it_interval; /* Interval for periodic timer */
               struct timeval it_value;    /* Time until next expiration */
    };

   struct timeval {
       time_t      tv_sec;         /* seconds */
       suseconds_t tv_usec;        /* microseconds */
   };
```
- `it_interval` 用于设定两次定时任务之间的时间间隔
- `it_value` 定时的时长
- 演示`demo`如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/time.h>
int main()
{
    // 使用 setitmer 完成定时任务
    struct itimerval new_value;
    struct itimerval old_value;
    new_value.it_interval.tv_sec = 1;
    new_value.it_interval.tv_usec = 0;
    new_value.it_value.tv_sec = 1;
    new_value.it_value.tv_usec = 0;
    // 相当于设置 alarm(1) ,可以一次设置多个值
    setitimer(ITIMER_REAL, &new_value , &old_value);
    printf("old_value.it_interval.tv_sec = %ld \n" , old_value.it_interval.tv_sec);
    printf("old_value.iterval.tv_usec = %ld \n" , old_value.it_interval.tv_usec);
    int i = 1;
    while(1){
        printf("%d \n" , i);
        i ++;
    }
}
```
- 但是如果使用第一种模式,其实他会发送一个终止进程的停止闹钟信号,所以就像只是设置了一轮一样,注意两个定时器时间间隔和一个定时器的执行之间之间的区别
### 信号集操作函数
- 阻塞信号集可以操作,未决信号集不可以操作但是通过阻塞信号集的方式操作未决信号集
- 作用: 设置自定义信号集,后面就是传入参数
- 信号集设置的函数如下:
```c
       int sigemptyset(sigset_t *set);
       int sigfillset(sigset_t *set);

       int sigaddset(sigset_t *set, int signum);
       int sigdelset(sigset_t *set, int signum);

       int sigismember(const sigset_t *set, int signum);
```
- 名称可以显示各个函数的作用,作用分别是:
  - 信号集设置为空
  - 信号集填充
  - 信号集添加某一个位
  - 信号集删除某一个位
  - 判断信号集中的位
- 参数:
  - `set`  表示一个位图
#### sigprocmask 函数
- 作用: 用于屏蔽信号,解除信号也可以使用这一个函数,他的本质,读取或者修改进程的信号品屏蔽字(`PCB`中)
- 注意: 屏蔽信号,只是将信号延后执行(延后到接触屏蔽),并且忽略将信号丢处理
- 函数原型如下:
```c
 int sigprocmask(int how, const sigset_t *_Nullable restrict set,
                                  sigset_t *_Nullable restrict oldset);

```
- 参数解释
- `set`: 表示一个传入参数,是一个位图,`set`中位置为`1`,就表示当前进程屏蔽哪一个信号
- `oldset`: 传出参数,保存旧的信号屏蔽集(就的`mask`)
- `how`参数取值:  假设当前的信号屏蔽字为`mask`
  - `SIG_BLOCK` 当`how`设置为这一个值的时候,`set`表示需要屏蔽的信号,相当于 `mask = mask | set`
  - `SIG_UNBLOCK` 当`how`设置为这一个值的时候,`set`表示需要解除屏蔽的信号,相当于`mask = mask & ~set`
  - `SIG_SETMASK` 当`mask`设置为这一个值的时候,`set`用于替代与原始屏蔽和新的屏蔽集,相当于 `mask = set ` ,调用`sigprocmask`解除了对于当前若干个信号的阻塞,则在`sigprocmask`返回之前,至少将其中一个信号递达
#### sigpending函数
- 作用: 读取未决信号集
- 函数原型:
```c
int sigpending(sigset_t *set);
```
- 参数:
  - `set` 表示一个传出参数

- 实践方式: 首先利用 `sigemptyset` 等函数自定义信号集对于`set`进行设置,之后利用 `sigprocmask`函数操作信号即,注意`how`参数,利用`sigpending`查看未决信号集
- 信号集合函数演示如下:
- 注意信号一定需要产生之后,才可以被屏蔽,如果信号产生也就谈不上是否被屏蔽,屏蔽之后对应的位图中的位就会发生改变
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
#include<errno.h>
void sys_err(const char* msg)
{
    perror(msg);
    exit(1);
}

void print_set(sigset_t* set)
{
    for(int i = 1 ; i <= 32 ; i ++){
        if(sigismember(set , i)){
            // 表示存在
            putchar('1');
        } else {
            putchar('0');
        }
    }
        printf("\n");
}
int main()
{
    sigset_t set , oldset;
    int ret;
    sigemptyset(&set);
    sigaddset(&set , SIGINT);
    sigaddset(&set , SIGKILL);
    sigaddset(&set , SIGSTOP);
    sigaddset(&set , SIGQUIT);
    // 开始进行改变
    ret = sigprocmask(SIG_BLOCK , &set , &oldset);
    if(ret == -1){
        sys_err("sigprocmask error");
    }
    sigset_t pedset;
    // 注意发生信号才可以解析
    while(1){
        ret = sigpending(&pedset);
        if(ret == -1){
            sys_err("sigpending failed !!! \n");
        }
        print_set(&pedset);
        sleep(1);    
    }
    
}
```
### 信号捕捉
#### signal函数
- 作用: 注册一个捕捉函数(并不是完成信号的捕捉)(这是信号递达之后的事情)
- 函数原型:
```c
 #include <signal.h>

       typedef void (*sighandler_t)(int);

       sighandler_t signal(int signum, sighandler_t handler);

```
- 注意函数指针的定义方式,这样定义就会使得,`sighandler_t`成为一个类型,这一个类型指向形如 `function<void(int)>` 的函数,当然可以使用 `function<void(int)>`进行包装
- 参数:
  - `signum` 表示信号
  - `handler` 表示处理方式
- 演示`demo`如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
void handler_func(int signal)
{
    printf("catch you !!! %d  \n" , signal);
}
int main()
{
    // 演示捕捉进程
    while(1){
        signal(SIGINT , handler_func);
    }
}
```
#### sigaction函数
- 实现捕捉函数的注册
- 函数原型如下:
```c
  int sigaction(int signum,
                     const struct sigaction *_Nullable restrict act,
                     struct sigaction *_Nullable restrict oldact);

```
- 参数:
  - `signum`: 需要捕捉的信号
  - `act`: 指定捕捉函数,`sa_mask sa_flags`等信息
  - `oldact`: 传出参数表示之前的配置信息 
- 参数中的结构体如下:
```c
   struct sigaction {
               void     (*sa_handler)(int); // 信号处理方式
               void     (*sa_sigaction)(int, siginfo_t *, void *); // 携带复杂结构体
               sigset_t   sa_mask; // 作用于信号捕捉函数活动期间
               int        sa_flags;
               void     (*sa_restorer)(void);
           };
```
- 由于信号捕捉的优先级高于信号处理的优先级别,如果不设置`sa_mask` 变量,`PCB`中的`mask`从进程创建开始一直存在,所以如果在这一个进程执行的时候,由另外一个信号发送给这一个进程如果还是依赖于同样的`mask`就会导致相当的信号重复捕捉重复执行到时循环,所以引入`sa_mask`,这一个变量在信号处理的过程中替代`mask`从而防止这一种情况
- 绝大多情况下`sa_mask` 和 `sa_flags`都可以传递 `0` 作为参数
- 使用`demo`如下:
```c
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<signal.h>
void catch_signal(int signal)
{
    printf("catch you %d !!! \n" , signal);
}
int main()
{
    // 利用 sigaction 函数进行信号的捕捉
    struct sigaction act , oldact;
    act.sa_handler = catch_signal;
    // 注意清除的方式
    sigemptyset(&act.sa_mask); // 相当于清空  sa_mask
    act.sa_flags = 0;
    // 开始注册
    int ret;
    ret = sigaction(SIGINT , &act , &oldact);
    if(ret == -1){
        perror("sigaction failed !!! \n");
        exit(1);
    }
    ret = sigaction(SIGQUIT , &act , &oldact);
    if(ret == -1){
        perror("sigaction failed !!! \n");
        exit(1);
    }
    while(1);
}
```
#### 信号捕捉特性
- 进程正常运行的时候,默认的`PCB`中一个信号屏蔽字(`mask`),他决定了进程自动屏蔽那些信号,当注册了某个信号捕捉函数,捕捉到该信号之后,要调用该函数,而该函数有可能需要执行很长时间,在这一个期间所屏蔽的信号不会由`mask`来指定,而是由`sa_mask`指定,调用完信号处理函数就会恢复为 `mask`
- `XXX` 信号捕捉函数执行期间,`XXX`信号自动屏蔽(`sa_flags = 0`)
- 阻塞的常规信号不支持排队,产生多次只会记录一次(但是后面32个实时信号支持排队)
- 如果需要在捕捉某一个信号的同时屏蔽另外一个信号可以考虑设置`sa_mask`的值来屏蔽另外一个信号
#### 内核实现进程捕捉的过程
![alt text](img/Screenshot_20240827_173928_tv.danmaku.bilibilihd.jpg)
### SIGCHLD信号
- `SIGCHLD`信号的产生条件:
  - 子进程终止的时候
  - 子进程接收到`SIGSTOP`信号停止的时候
  - 子进程处于停止状态,接收到`SIGCONT`之后唤醒
#### 使用 SIGCHLD 信号回收子进程
- 子进程结束之后,其父进程会受到`SIGCHLD`信号,该信号的默认处理动作就是忽略,可以捕捉该信号,在捕捉函数中完成进程状态的回收
- 如果使用如下代码,那么就会导致处理信号的时候,子进程发送的信号就会被屏蔽,导致子进程无法被回收,导致僵尸进程的产生
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<signal.h>
#include<sys/wait.h>
void handler_child(int signo)
{
    // 回收子进程
    int wpid;
    wpid = wait(NULL);
    printf("Successfully resource my child: %d \n" , wpid);
}
int main()
{
    // 利用 SIGNCHLD 信号回收子进程
    int i ;
    for(i = 0 ; i < 5 ; i ++){
        if(fork() == 0){
            break;
        }
    }
    if(i == 5){
        // 表示父进程,开始回收子进程
        // 回收
        // 首先注册
        struct sigaction act;
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        act.sa_handler = handler_child;
        sigaction(SIGCHLD , &act , NULL);
        while(1){
            printf("I am the parent , my pid is %d \n" , getpid());
            sleep(1);
        }
    } else {
        // 子进程
        printf("I am the child ,my pid is %d , my ppid is %d \n" , getpid() , getppid());

    }
}
```
- 利用 `SIGCHLD` 进行的最佳实践如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/wait.h>
#include<signal.h>
// 定义捕捉函数
void catch_child(int signo)
{
    int wpid ,status;
    // 循环回收连续结束的子进程
    while((wpid = waitpid(-1 , &status , 0)) != -1){
        if(WIFEXITED(status)){
            printf("Successfully resource child whose pid is %d and return_val is %d \n" , wpid , WEXITSTATUS(status));
        }
    }
}
int main()
{
    // 设置 SIGCHLD 阻塞
    sigset_t sig;
    sigemptyset(&sig);
    sigaddset(&sig , SIGCHLD);
    sigprocmask(SIG_BLOCK , &sig , NULL);
    int i;
    for(i = 0 ; i < 15 ; i ++){
        if(fork() == 0){
            break;
        }
    }
    if(i == 15){
        // 父进程
        // 首先进行注册
        struct sigaction act;
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        act.sa_handler = catch_child;
        sigaction(SIGCHLD , &act , NULL);
        // 解除
        sigset_t new_sig;
        sigemptyset(&new_sig);
        sigaddset(&new_sig , SIGCHLD);
        sigprocmask(SIG_UNBLOCK , &new_sig , NULL);
        while(1){
            printf("I am parent , my pid is %d \n" , getpid());
            sleep(1);
        }
    } else {
        printf("I am child , my pid is %d , my ppid is %d \n" , getpid() , getppid());
        return i + 1;
    }
}
```
- 首先明确第一程序中出现的问题: 当父进程回收其他子进程的时候,此时另外的子进程发送 `SIGCHLD` 信号,此时这些信号就不会被捕捉到,所以这里采用循环捕获的方法进行捕获,从而使得多个子进程同时死亡的时候可以捕获
- 另外一个问题就是如果子进程在注册捕捉函数之前死亡,父进程就无法捕捉到了,所以这里首先需要在主进程中屏蔽调 `SIGCHLD` 信号,之后注册完成之后继续取消对于 `SIGCHLD` 信号的屏蔽
- 利用`SIGCHLD`的方式回收子进程的一个好处就是可以不再妨碍父进程的工作的情况下进行子进程的回收
## 中断系统调用
- 两类系统调用:
  1. 慢速系统调用: 可能会使进程永远阻塞的一类,如果在阻塞期间受到一个信号,该系统调用就会被中断,不再继续执行(早期),也可以设定系统调用是否重启,比如`read` , `write` , `pause` , `wait`(子进程不死,就会一直阻塞) ...
  2. 其他系统调用: `getpid` `getppid` `fork` ...
- 满足系统调用被中断的相关行为,其实都是`pause` 的行为,比如`read` 
  - 想要中断`pause`, 信号不可以被屏蔽
  - 信号的处理方式必须是捕捉(默认,忽略都不可以)
  - 中断之后返回 `-1`, 设置 `errorno`为`EINTR` (表示 "被信号中断")
- 可以修改`sa_flags`参数来设置被信号中断之后,系统调用是否重启,`SA_INTERRURT` 表示不重启,`SA_RESTART`表示重启
- 拓展了解:
  - `sa_flags`还有很多可选参数,适用于不同的情况,比如捕捉到信号之后,在执行捕捉函数的期间,不希望自动阻塞该信号,可以将`sa_flags`设置为`SA_NODERER`,除非`sa_mask`中包含这一个信号
- 如果想要给捕捉信号发送结构体等类型,需要(`sa_flags`)传递 `SIGINFO` 参数
## 会话
- 会话: 表示用户和操作系统进行交互的一段时间,`Linux`下的体现就是终端
- 创建一个会话需要注意以下`6`点:
  - 调用进程不可以是进程组组长,该进程变成会话首进程(`session header`)
  - 该进程成为一个新进程组组长的组长进程
  - 需要有`root`权限(`ubuntu`不需要)
  - 新的会话丢弃原有的控制终端,该会话没有控制终端
  - 该调用进程未组长进程,就会出错返回
  - 建立新的会话的时候,首先调用 `fork` , 父进程终止,子进程调用 `setsid()`
### getsid函数
- 获取进程所属的会话 `ID`
  - `pid_t getsid(pid_t pid)`
  - 成功返回调用进程的会话`ID`,失败就会返回 `-1` 并且设置 `errorno`
### setsid函数
- 作用: 创建一个会话,并且使用自己的`ID`设置进程组`ID`,同时也是新会话的`ID`
- 函数原型:
```c
pid_t setsid(void);
```
- 返回值:
  - 成功返回调用进程的会话`ID`
  - 失败返回 `-1` 并且设置 `errorno`
- `ps ajx` 命令中的 `SID TTY` 就是会话 `id`
- 利用子进程调用会话之后可以得到:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
int main()
{
    int pid  = fork();

    if(pid > 0){
        printf("I am father , my pid is %d \n" , getpid());
    } else if(pid == 0){
        // 表示子进程
        // 首先查看 sid
        int old_sid = getsid(0); // 表示查看当前进程的 sid
        printf("old_sid = %d \n " , old_sid);
        printf("group id = %d \n" , getpgid(0));
        printf("old_pid = %d \n" , getpid());
        setsid(); // 表示开启新的会话
        int new_sid = getsid(0);
        printf("new_sid = %d \n " , new_sid);
        printf("group id = %d \n" , getpgid(0));
        printf("new_pid = %d \n" , getpid());
    }
}
```
- 调用结果如下:
```text
I am father , my pid is 99089 
old_sid = 98861 
 group id = 99089 
old_pid = 99090 
new_sid = 99090 
 group id = 99090 
new_pid = 99090 
```
- 可见,用于创建会话的进程首先使用自己的`pid`创建会话,同时以自己的`pid`命名进程组并且成为进程组的组长
## 守护进程
- `Daemon`(精灵)守护进程,是`Linux`中后台服务进程,通常独立于控制终端并且周期性执行某种任务或者等待某些发生的事件,一般都是采用 `d` 结尾的名称命名
- `Linux`后台的一些系统服务进程,没有控制终端,不可以直接和用户进行交互,不受用户登陆,注销的影响,一直在运行着,他们都是守护进程,比如预读入缓输出机制的实现: `ftp`服务器,`nfs`服务器等
- 创建守护进程,最关键的一部就是调用 `setsid` 函数创建一个新的`Session`并且成为 `Session leader`
### 创建守护进程
- 创建守护进程流程分析:
  - 创建子进程,父进程退出(所有工作在子进程中进行形式脱离了控制终端)
  - 在子进程中创建新会话(`setsid()`函数,使得子进程完全独立出来,脱离控制)
  - 改变当前目录位置(`chdir()`函数,防止占用可以卸载的文件系统(比如`U`盘等),可以换成其他目录(最好固定比如`~`或者`/`))
  - 设置文件权限掩码(`umask()`函数,防止继承的文件创建屏蔽字拒绝某些权限,增加守护进程灵活性)
  - 关闭文件描述符(标准输入标准输出等)(继承的打开文件不会用到,浪费系统资源,无法卸载)(或者重定向给`/dev/null`(空洞))
  - 开始执行守护进程核心工作,守护进程退出处理程序模型
#### 创建守护进程实现方式
- 相当于创建了一个后台运行的一个程序
- 创建代码如下:
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/stat.h>
int main()
{
    // 1. 首先创建子进程
    int pid = fork();
    int ret;
    if(pid > 0){
        // 父进程
        exit(0);
    } else if(pid == 0){
        // 等待父进程退出
        sleep(1);
        // 2. 创建会话
        ret = setsid();
        if(ret == -1){
            perror("setsid() error ");
            exit(1);
        }
        // 3. 改变工作目录
        ret = chdir("/home/loser");
        if(ret == -1){
            perror("chdir() error");
            exit(1);
        }
        // 4. 设置 umask
        
        umask(0022); // 由于新创建的文件没有执行权限,所以需要利用这一掩码 权限 & ~umask
        // 5. 进行输入输出重定向或者关闭
        int fd = open("/dev/null" , O_RDWR);
        if(fd == -1){
            perror("open() failed ");
            exit(1);
        }
        close(STDIN_FILENO); // 关闭文件描述符 0 
        dup2(fd , STDOUT_FILENO);
        dup2(fd , STDERR_FILENO);
        // 6. 处理核心业务逻辑
        while(1){
            // 模拟守护进行的业务逻辑
            
        }
    }
}
```
- 注意文件掩饰代码的设置,可以参考: https://blog.csdn.net/2401_84967954/article/details/138983541