> 同步操作: "同步操作"是指在计算机科学和信息技术中的一种操作方式，其中不同的任务或操作按顺序执行，一个操作完成后才能开始下一个操作。在多线程编程中，各个任务通常需要通过**同步设施**进行相互**协调和等待**，以确保数据的**一致性**和**正确性**。
## 等待事件或条件
- 等待事件发生或者条件成立的三种方式:
	- 忙等待(自旋)
	- 延时等待
	- 条件变量
### 条件变量
- `C++`标准库中提供了条件变量的两种实现方法: `std::condition_variable`和`std::condition_variable_any`,其中`std::condition_variable`必须工作在 `unique_lock`上面,但是 `std::condition_variable_any`可以工作与任何可锁定对象上面,但是开销比较大,所以一般情况下使用 `std::condition_variable`,使用例子如下:
```c++
/* 条件变量 condition_variable 的使用 */
#include<iostream>
#include<thread>
#include<condition_variable>
#include<mutex>
using namespace std;

mutex mtx;
condition_variable cv;
bool arrived;

void wait_for_arrival() {
    unique_lock<mutex> lck{mtx};
    cv.wait(lck , []() { return arrived; });
    cout << "到达目的地,准备下车了 ..." << endl;
}

void simulate_arrival() {
    this_thread::sleep_for(chrono::seconds(5));
    {
        lock_guard<mutex> l(mtx);
        arrived = true;
    }

    cv.notify_one();
}


int main() {
    thread t1{wait_for_arrival};
    thread t2{simulate_arrival};
    t1.join();
    t2.join();
}
```
注意到`unique_lock`和`lock_guard`其实都是对于互斥锁的包装,底层都需要使用`mutex`初始化,其中条件变量 `cv.wait(lck , []{return arrival;});` 会首先释放掉底层的互斥锁,之后等待条件满足重新上锁(这里和`POSIX`中的条件变量不同它,条件不需要循环等待),其中`wait`函数的声明如下:
```c++
void wait(std::unique_lock<std::mutex>& lock);                 // 1

template<class Predicate>
void wait(std::unique_lock<std::mutex>& lock, Predicate pred); // 2
```
其实就等价于:
```c++
while(!pred()) {
	wait(lock);
}
```

#### 线程安全的队列
- 利用条件变量可以实现线程安全的队列,并且基于该数据结构实现生产-消费者模型:
```c++
#include <chrono>
#include<iostream>
#include<queue>
#include<mutex>
#include<condition_variable>
#include <ratio>
#include<thread>
#include<memory>
using namespace std;

template<typename T>
class threadsafe_queue {
private:
    mutable mutex m;
    condition_variable data_cond;
    queue<T> data_queue;
public:
    void push(T value) {
        {
            lock_guard<mutex> l{m};
            data_queue.push(value);
            cout << "thread: " << this_thread::get_id() << " push " << value << " into the queue " << endl;
        } 
        data_cond.notify_one();
    }

    void pop(T& value) {
        unique_lock<mutex> u{m};
        data_cond.wait(u , [this]{ return !data_queue.empty(); });
        value = data_queue.front();
        cout << "thread: " << this_thread::get_id() << " get " << value << " from queue " << endl;
        data_queue.pop();
    }
    
    shared_ptr<T> pop() {
        unique_lock<mutex> u{m}; 
        data_cond.wait(u , [this]{ return !data_queue.empty(); });
        shared_ptr<T> res{make_shared<T>(data_queue.front())};
        data_queue.pop();
        return res;
    }

    bool empty() const {
        lock_guard<mutex> l{m};
        return data_queue.empty();
    }
};

void producer(threadsafe_queue<int>& q) {
   for(int i = 0 ; i < 5 ; i ++) {
        q.push(i);
        this_thread::sleep_for(chrono::seconds(2));
   } 
}

void consumer(threadsafe_queue<int>& q) {
    for(int i = 0 ; i < 10 ; i ++) {
        int value{};
        q.pop(value);
        this_thread::sleep_for(chrono::seconds(1));
    }
}

int main() {
    threadsafe_queue<int> q{};
    thread t1{producer , ref(q)};
    thread t2{consumer , ref(q)};
    t1.join();
    t2.join();
}
```
同时使用条件变量可以实现通知的效果,比如一个线程在等待一个结果的时候,另外一个线程完成操作之后可以通过条件变量来通知阻塞的线程
### 使用 std::future
- `C++`中的`std::future`用于处理线程中需要等待的某一个事件的情况,线程直到预期结果,等待的同时也可以执行其他的任务(好相类似于`js`中的`promise`),标准库中有两种 `future`  , 包含独占的`std::future`和共享的 `std::shared_future`,其中`std::future`只可以与单个指定事件关联,而`std::shared_future`可以关联多个事件,并且当多个线程需要访问一个独立的 `future`对象的时候,必须使用互斥量或者类似的同步机制来保护,但是当多个线程访问同一个共享状态,若每一个线程都是通过自身的`shared_futrue`对象副本进行访问,则是线程安全的,注意`std::futrue<T>`中的模板参数是一部任务函数的返回值,一个简单的使用例子如下:
```c++
/* std::future 的基本使用 */
#include <chrono>
#include <ios>
#include<iostream>
#include<thread>
#include<future>
using namespace std;

int task(int n) {
    cout << "异步任务 ID: " << this_thread::get_id() << endl;
    this_thread::sleep_for(chrono::seconds(5));
    return n * n;
}

int main() {
    future<int> future = async(task , 10);    
    cout << "main: " << this_thread::get_id() << endl;
    cout << boolalpha << future.valid() << endl;
    cout << future.get() << endl;
    cout << boolalpha << future.valid() << endl;
}
```
同时,`std::async`也支持各种可调用对象类型,实例如下:
```c++
/* async 参数测试 */
#include<iostream>
#include<future>

using namespace std;

class X {
public:
    int operator()(int n) const {
        return n * n;
    }
};

class Y {
public:
    int task_y(int n) {
        return n * n * n;
    } 
};

int f(int& p) {
    return p * p;
}

int main(int argc , char** argv) {
    Y y;
    int n = 9;
    auto t1 = async(X{} , 10);
    auto t2 = async(&Y::task_y , &y , 8);
    auto t3 = async([]{return -1;});
    auto t4 = async(f , ref(n));

    cout << "t1: " << t1.get() << endl;
    cout << "t2: " << t2.get() << endl;
    cout << "t3: " << t3.get() << endl;
    cout << "t4: " << t4.get() << endl;
    return 0;
}
```
考虑如下情况:
```c++
void f(const int& p) {}
void f2(int& p ){}

int n = 0;
std::async(f, n);   // OK! 可以通过编译，不过引用的并非是局部的n
std::async(f2, n);  // Error! 无法通过编译
```
由于临时对象可以绑定在`const`修饰的左值上面,而不可以绑定在非`const`修饰的左值上面,所以下面不可以通过编译
- 同时对于只支持移动构造或者移动赋值的对象,需要使用移动构造函数
#### std::async的执行策略
- 三种执行策略:
	- `std::launch::async` 在不同线程上执行异步任务
	- `std::launch::deferred` 惰性求值,不创建线程,等待`future`对象调用`wait`或`get`成员函数的时候执行任务
	- `std::launch::async | std::launch::deferred` 根据实际情况选择执行方法,比如可以根据系统的资源剩余情况选择
- 使用举例如下:
```c++
/* std::async 的执行策略 */
#include<iostream>
#include<future>
#include <thread>
using namespace std;

void f1() {
    cout << "异步任务 f1 开始执行 ..." << "thread: " << this_thread::get_id() <<  endl;
    this_thread::sleep_for(chrono::seconds(3));
}
int main() {
    auto ff1 = async(launch::deferred , f1);    
    cout << "没有开始异步任务 f1" << "main: " << this_thread::get_id() << endl;
    ff1.wait();
    auto ff2 = async(launch::async , f1);
    auto ff3 = async(launch::async | launch::deferred , f1);
}
```

其中`std::launch::async`相当于不会开始新的线程执行任务,相当于回调函数
#### std::async的常见问题
1. 如果使用`std::async`构造的对象没有移动或者没有绑定到引用,那么完整表达式的结尾`std::future`的析构函数就会被阻塞,直到异步任务完成,所以导致这样无法创建异步任务:
```c++
std::async(std::launch::async, []{ f(); }); // 临时量的析构函数等待 f()
std::async(std::launch::async, []{ g(); }); // f() 完成前不开始
```
2. 被移动的`std::future`没有所有权,失去了共享状态,不可以调用`get`和`wait`成员函数,举例如下:
```c++
auto t = std::async([] {});
std::future<void> future{ std::move(t) };
t.wait();   // Error! 抛出异常
```
#### future 和 std::packaged_task
