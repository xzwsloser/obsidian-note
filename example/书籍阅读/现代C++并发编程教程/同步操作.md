> 同步操作: "同步操作"是指在计算机科学和信息技术中的一种操作方式，其中不同的任务或操作按顺序执行，一个操作完成后才能开始下一个操作。在多线程编程中，各个任务通常需要通过**同步设施**进行相互**协调和等待**，以确保数据的**一致性**和**正确性**。
## 等待事件或条件
- 等待事件发生或者条件成立的三种方式:
	- 忙等待(自旋)
	- 延时等待
	- 条件变量
### 条件变量
- `C++`标准库中提供了条件变量的两种实现方法: `std::condition_variable`和`std::condition_variable_any`,其中`std::condition_variable`必须工作在 `unique_lock`上面,但是 `std::condition_variable_any`可以工作与任何可锁定对象上面,但是开销比较大,所以一般情况下使用 `std::condition_variable`,使用例子如下:
```c++
/* 条件变量 condition_variable 的使用 */
#include<iostream>
#include<thread>
#include<condition_variable>
#include<mutex>
using namespace std;

mutex mtx;
condition_variable cv;
bool arrived;

void wait_for_arrival() {
    unique_lock<mutex> lck{mtx};
    cv.wait(lck , []() { return arrived; });
    cout << "到达目的地,准备下车了 ..." << endl;
}

void simulate_arrival() {
    this_thread::sleep_for(chrono::seconds(5));
    {
        lock_guard<mutex> l(mtx);
        arrived = true;
    }

    cv.notify_one();
}


int main() {
    thread t1{wait_for_arrival};
    thread t2{simulate_arrival};
    t1.join();
    t2.join();
}
```
注意到`unique_lock`和`lock_guard`其实都是对于互斥锁的包装,底层都需要使用`mutex`初始化,其中条件变量 `cv.wait(lck , []{return arrival;});` 会首先释放掉底层的互斥锁,之后等待条件满足重新上锁(这里和`POSIX`中的条件变量不同它,条件不需要循环等待),其中`wait`函数的声明如下:
```c++
void wait(std::unique_lock<std::mutex>& lock);                 // 1

template<class Predicate>
void wait(std::unique_lock<std::mutex>& lock, Predicate pred); // 2
```
其实就等价于:
```c++
while(!pred()) {
	wait(lock);
}
```

#### 线程安全的队列
- 利用条件变量可以实现线程安全的队列,并且基于该数据结构实现生产-消费者模型:
```c++
#include <chrono>
#include<iostream>
#include<queue>
#include<mutex>
#include<condition_variable>
#include <ratio>
#include<thread>
#include<memory>
using namespace std;

template<typename T>
class threadsafe_queue {
private:
    mutable mutex m;
    condition_variable data_cond;
    queue<T> data_queue;
public:
    void push(T value) {
        {
            lock_guard<mutex> l{m};
            data_queue.push(value);
            cout << "thread: " << this_thread::get_id() << " push " << value << " into the queue " << endl;
        } 
        data_cond.notify_one();
    }

    void pop(T& value) {
        unique_lock<mutex> u{m};
        data_cond.wait(u , [this]{ return !data_queue.empty(); });
        value = data_queue.front();
        cout << "thread: " << this_thread::get_id() << " get " << value << " from queue " << endl;
        data_queue.pop();
    }
    
    shared_ptr<T> pop() {
        unique_lock<mutex> u{m}; 
        data_cond.wait(u , [this]{ return !data_queue.empty(); });
        shared_ptr<T> res{make_shared<T>(data_queue.front())};
        data_queue.pop();
        return res;
    }

    bool empty() const {
        lock_guard<mutex> l{m};
        return data_queue.empty();
    }
};

void producer(threadsafe_queue<int>& q) {
   for(int i = 0 ; i < 5 ; i ++) {
        q.push(i);
        this_thread::sleep_for(chrono::seconds(2));
   } 
}

void consumer(threadsafe_queue<int>& q) {
    for(int i = 0 ; i < 10 ; i ++) {
        int value{};
        q.pop(value);
        this_thread::sleep_for(chrono::seconds(1));
    }
}

int main() {
    threadsafe_queue<int> q{};
    thread t1{producer , ref(q)};
    thread t2{consumer , ref(q)};
    t1.join();
    t2.join();
}
```
同时使用条件变量可以实现通知的效果,比如一个线程在等待一个结果的时候,另外一个线程完成操作之后可以通过条件变量来通知阻塞的线程













