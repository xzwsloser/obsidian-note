 ä¸»è¦è§£å†³å¤šä¸ªçº¿ç¨‹åœ¨æ“ä½œåŒä¸€ä»½å…±äº«æ•°æ®æ—¶äº§ç”Ÿçš„çº¿ç¨‹å®‰å…¨é—®é¢˜

å½“æŸä¸ªè¡¨è¾¾å¼çš„æ±‚å€¼å†™å…¥æŸä¸ªå†…å­˜ä½ç½®ï¼Œè€Œå¦ä¸€æ±‚å€¼è¯»æˆ–ä¿®æ”¹åŒä¸€å†…å­˜ä½ç½®æ—¶ï¼Œç§°è¿™äº›**è¡¨è¾¾å¼å†²çª**ã€‚**æ‹¥æœ‰ä¸¤ä¸ªå†²çªçš„æ±‚å€¼çš„ç¨‹åºå°±æœ‰æ•°æ®ç«äº‰**ï¼Œé™¤é
- ä¸¤ä¸ªæ±‚å€¼éƒ½åœ¨åŒä¸€çº¿ç¨‹ä¸Šï¼Œæˆ–è€…åœ¨åŒä¸€ä¿¡å·å¤„ç†å‡½æ•°ä¸­æ‰§è¡Œï¼Œæˆ–
- ä¸¤ä¸ªå†²çªçš„æ±‚å€¼éƒ½æ˜¯åŸå­æ“ä½œï¼ˆè§ `std::atomic`ï¼‰ï¼Œæˆ–
- ä¸€ä¸ªå†²çªçš„æ±‚å€¼å‘ç”Ÿæ—©äºâ€Šå¦ä¸€ä¸ªï¼ˆè§ `std::memory_order`ï¼‰
ä¸‹é¢ä»‹ç»è§£å†³ç«äº‰å¯¼è‡´çš„çº¿ç¨‹å®‰å…¨é—®é¢˜çš„æ–¹æ³•
## ä½¿ç”¨äº’æ–¥é‡
### std::mutex
- `std::mutex` ä¸ºäº’æ–¥é”,å¯ä»¥ç”¨äºä¿æŠ¤å…±äº«æ•°æ®,è§£å†³çº¿ç¨‹å®‰å…¨é—®é¢˜,ä½¿ç”¨ä¸¾ä¾‹å¦‚ä¸‹:
```c++
#include<iostream>
#include<thread>
#include<mutex>
#include<vector>

using namespace std;
mutex m;

int main() {
    auto f = [](int i) {
        m.lock();
        cout << "thread: "  << this_thread::get_id() << " get: " << i << endl;   
        m.unlock();
    }; 

    vector<thread> threads;
    for(int i = 0 ; i < 10 ; i ++) {
        threads.emplace_back(f , i);
    }

    for(auto& t : threads) {
         if(t.joinable()) {
            t.join();
         }
    }
}
```
### std::lock_guard
- ä½¿ç”¨äº† `RAII` æ€æƒ³,æŠŠäº’æ–¥é”çš„è§£é”å’Œå¯¹è±¡çš„ææ„å‡½æ•°è”ç³»èµ·æ¥äº†
- æ‹¥æœ‰ä¸¤ä¸ªæ„é€ å‡½æ•°:
```c++
explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) {
	_MyMutex.lock(); 
} 
lock_guard(_Mutex& _Mtx, adopt_lock_t) noexcept: _MyMutex(_Mtx) {} // construct but don't lock
```
- ä¸Šé¢ä¸€ä¸ªæ„é€ å‡½æ•°åœ¨ç®¡ç†äº’æ–¥é”ä¹‹åä¼šä¸Šé”,å¦‚æœåŸæ¥çš„äº’æ–¥é”ä¸Šé”äº†,å°±ä¼šå½¢æˆæ­»é”,åé¢ä¸€ä¸ªéœ€è¦æå‰ä¸Šé”,ç¦»å¼€`lock_guard`ä½œç”¨åŸŸä¹‹åè§£é”(ä¸éœ€è¦è‡ªå·±è§£é”)
- ä¸¾ä¾‹å¦‚ä¸‹:
```c++
#include <chrono>
#include<iostream>
#include<thread>
#include<vector>
#include<mutex>
using namespace std;

mutex m;
int main() {
    auto f = [](int i) {
            m.lock();
             {
                lock_guard<mutex> l{m , adopt_lock};
                cout << "æ˜¯å¦æ­£å¸¸æ‰“å°" << i << endl;
             }
             this_thread::sleep_for(chrono::seconds(10 - i));
             cout << "hello" << i << endl;
               /*cout << "thread: " << this_thread::get_id() << " get: " << i << endl;*/
    };

    vector<thread> threads;
    for(int i = 0 ; i < 10 ; i ++) {
        threads.emplace_back(f , i);
    }

    for(auto& t : threads) {
        if(t.joinable()) {
            t.join();
        }
    }
}
```
### try_lock
- `try_lock` ä¼šå°è¯•ä¸Šé”,ä½†æ˜¯å¦‚æœé”å·²ç»è¢«å…¶ä»–çš„çº¿ç¨‹å ç”¨äº†,å°±ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹,è€Œæ˜¯ç›´æ¥è¿”å›,è¿”å›ç±»å‹ä¸º `bool` , ä¸Šé”æˆåŠŸå°±è¿”å›`true` , å¦åˆ™è¿”å› `false`,ä¸¾ä¾‹å¦‚ä¸‹:
```c++
std::mutex mtx;

void thread_function(int id) {
    // å°è¯•åŠ é”
    if (mtx.try_lock()) {
        std::cout << "çº¿ç¨‹ï¼š" << id << " è·å¾—é”" << std::endl;
        // ä¸´ç•ŒåŒºä»£ç 
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // æ¨¡æ‹Ÿä¸´ç•ŒåŒºæ“ä½œ
        mtx.unlock(); // è§£é”
        std::cout << "çº¿ç¨‹ï¼š" << id << " é‡Šæ”¾é”" << std::endl;
    } else {
        std::cout << "çº¿ç¨‹ï¼š" << id << " è·å–é”å¤±è´¥ å¤„ç†æ­¥éª¤" << std::endl;
    }
}
```
## ä¿æŠ¤å…±äº«æ•°æ®
- ä¿æŠ¤å…±äº«æ•°æ®çš„ä¸€ç§å‡†åˆ™: åªèƒ½åœ¨å—äº’æ–¥é”ä¿æŠ¤çš„åŒºåŸŸé‡Œé¢ä½¿ç”¨å…±äº«æ•°æ® , å°½é‡ä¸è¦å§å…±äº«æ•°æ®ä»¥å¼•ç”¨çš„æ–¹å¼ä¼ é€’ç»™å¤–ç•Œ,å¦åˆ™å°±å¯èƒ½ä½¿å¾—å¤–ç•Œä¹Ÿå¯ä»¥è®¿é—®å…±äº«æ•°æ®
## æ­»é”
### æ­»é”çš„åŸå› 
- å¤šä¸ªäº’æ–¥é‡æ‰å¯èƒ½é‡åˆ°æ­»é”é—®é¢˜,æ¯”å¦‚å¯¹äºä¸´ç•ŒåŒºçš„è®¿é—®åŠ ä¸Šå¤šæŠŠé”,ä½†æ˜¯é”çš„é¡ºåºä¸æ­£ç¡®,ä¸¾ä¾‹å¦‚ä¸‹:
```c++
#include <chrono>
#include<thread>
#include<mutex>
#include<vector>
using namespace std;

mutex m1 , m2;
int n;

void func1() {
    lock_guard<mutex> l1{m1};
    this_thread::sleep_for(chrono::seconds(2));
    lock_guard<mutex> l2{m2};
    ++n;
}

void func2() {
    lock_guard<mutex> l1{m2};
    lock_guard<mutex> l2{m1};
    ++n;
}

int main() {
    n = 0;
    vector<thread> f1s;
    for(int i = 0 ; i < 5 ; i ++) {
        f1s.emplace_back(func1);
    }

    vector<thread> f2s;
    for(int i = 0 ; i < 5 ; i ++) {
        f2s.emplace_back(func2);
    }

    for(int i = 0 ; i < 5 ; i ++) {
        f1s[i].join();
        f2s[i].join();
    }
}
```
åŒæ—¶ä¹Ÿæœ‰å¾ˆå¤šå€¼å¾—æ³¨æ„çš„ç»†èŠ‚,æ¯”å¦‚åœ¨ä¸‹å›¾ä¸­,ç”±äºä¼ å…¥çš„å‚æ•°ä¸åŒ,æœ€åå¯èƒ½å¯¼è‡´æ­»é”:
```c++
struct X{
    X(const std::string& str) :object{ str } {}

    friend void swap(X& lhs, X& rhs);
private:
    std::string object;
    std::mutex m;
};

void swap(X& lhs, X& rhs) {
    if (&lhs == &rhs) return;
    std::lock_guard<std::mutex> lock1{ lhs.m }; 
    std::lock_guard<std::mutex> lock2{ rhs.m }; 
    swap(lhs.object, rhs.object);
}

// å¯¼è‡´æ­»é”çš„æµ‹è¯•ä»£ç :
X a{ "ğŸ¤£" }, b{ "ğŸ˜…" };
std::thread t{ [&] {swap(a, b); } };  // 1
std::thread t2{ [&] {swap(b, a); } }; // 2
```
### æ­»é”çš„è§£å†³æ–¹æ³•
#### std::lock
- `std::lock`å¯ä»¥ç”¨äºç®¡ç†å¤šä¸ªäº’æ–¥é‡,å¦‚æœåœ¨ä¸Šé”çš„æ—¶å€™æŠ›å‡ºå¼‚å¸¸(æ¯”å¦‚å‡ºç°äº†æ­»é”) , æ­¤æ—¶å°±ä¼šå¯¹ä»»ä½•å·²é”çš„å¯¹è±¡è°ƒç”¨`unlock`è§£é”,ä¹Ÿå°±æ˜¯`std::lock` è¦ä¹ˆç»™äº’æ–¥é‡éƒ½ä¸Šé”,è¦ä¹ˆéƒ½ä¸é”,ä¸¾ä¾‹å¦‚ä¸‹:
```c++
/* åˆ©ç”¨ std::locké˜²èŒƒæ­»é”é—®é¢˜ */
#include<iostream>
#include<thread>
#include<mutex>
#include<vector>
using namespace std;
mutex m1 , m2;
int n;
void f1() {
    lock(m1 , m2);
    lock_guard<mutex> l1{m2 , adopt_lock};
    this_thread::sleep_for(chrono::seconds(1));
    lock_guard<mutex> l2{m1 , adopt_lock};
    n ++;
}

void f2() {
    /*lock(m1 , m2);*/
    lock_guard<mutex> l1{m1 , adopt_lock};
    lock_guard<mutex> l2{m2 , adopt_lock};
    n ++;
}

int main() {
    vector<thread> f1s;
    vector<thread> f2s;
    for(int i = 0 ; i < 5 ; i ++) {
        f1s.emplace_back(f1);
        f2s.emplace_back(f2);
    }

    for(int i = 0 ; i < 5 ; i ++) {
        f1s[i].join();
        f2s[i].join();
    }
}
```
#### std::scoped_lock
- `std::scoped_lock`æ˜¯`C++17`ä¸­æ–°å¢åŠ çš„ä¸€ä¸ªç±»,ç±»ä¼¼äº`std::lock` å’Œ `std::lock_guard` çš„ä½œç”¨,å¯ä»¥ç”¨äºç®¡ç†å¤šä¸ªäº’æ–¥é‡,ä¸¾ä¾‹å¦‚ä¸‹:
```c++
void swap(X& lhs, X& rhs) {
    if (&lhs == &rhs) return;
    std::scoped_lock guard{ lhs.m,rhs.m };
    swap(lhs.object, rhs.object);
}
```
#### é˜²èŒƒæ­»é”çš„æ–¹æ³•
- é˜²èŒƒæ­»é”çš„æ–¹æ³•å¦‚ä¸‹:
	- é¿å…åµŒå¥—é”
	- é¿å…åœ¨æŒæœ‰é”æ—¶è°ƒç”¨å¤–éƒ¨ä»£ç (ä¸è¦æŠŠéœ€è¦ä¿æŠ¤çš„å¯¹è±¡é€šè¿‡å¼•ç”¨çš„æ–¹å¼ä¼ é€’ç»™å¤–ç•Œ)
	- ä½¿ç”¨å›ºå®šé¡ºåºè·å–é”
#### std::unique_lock
- `std::unique_lock`æ˜¯`C++11`ä¸­å¼•å…¥çš„ä¸€ç§é€šç”¨çš„äº’æ–¥åŒ…è£…å™¨,å¯ä»¥å’Œæ¡ä»¶å˜é‡ä¸€èµ·ä½¿ç”¨,ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹:
```c++
/*  åˆ©ç”¨unique_locké˜²æ³›æ­»é” */
#include<iostream>
#include<functional>
#include<thread>
#include<mutex>
using namespace std;

mutex m1,m2;

class X {
public:
    string str;
    X(const string& s): str(s) {}
};

void swap_x(X& lhs , X& rhs) {
    if(&lhs == &rhs) return ;
    unique_lock u1{m1 , defer_lock};
    this_thread::sleep_for(chrono::seconds(3));
    unique_lock u2{m2 , defer_lock};
    lock(u1 , u2);
    swap(lhs.str , rhs.str);
}

int main() {
    X lhs("hello");
    X rhs("world");
    thread t1{swap_x , ref(lhs) , ref(rhs)};
    thread t2{swap_x , ref(rhs) , ref(lhs)};

    t1.join();
    t2.join();
}
```
å…¶ä¸­`std::unique_lock`çš„ç¬¬äºŒä¸ªå‚æ•° `std::defer_lock` è¡¨ç¤ºä¸è·å¾—äº’æ–¥ä½“çš„æ‰€æœ‰æƒ,æ²¡æœ‰æ‰€æœ‰æƒè‡ªç„¶æ„é€ å‡½æ•°å°±ä¸ä¼šä¸Šé”äº†,`std::unique_lock`çš„æ•°æ®æˆå‘˜å¦‚ä¸‹:
```c++
private:
    _Mutex* _Pmtx = nullptr;  // åº•å±‚çš„é”å¯¹è±¡
    bool _Owns    = false;    // æ˜¯å¦å…·æœ‰äº’æ–¥ä½“çš„æ‰€æœ‰æƒ
```
ç¬¬äºŒä¸ªå‚æ•°ä¸º `std::defer_lock`çš„æ„é€ å‡½æ•°å¦‚ä¸‹:
```c++
unique_lock(_Mutex& _Mtx, defer_lock_t) noexcept
    : _Pmtx(_STD addressof(_Mtx)), _Owns(false) {} // construct but don't lock
```
åŒæ—¶`std::unique_lock`ä¸­ä¹Ÿå«æœ‰`lock` , `try_lock`,`unlock`ç­‰æˆå‘˜å‡½æ•°,æ‰€ä»¥å¯ä»¥ä¼ é€’ç»™`std::lock`è¿›è¡Œè°ƒç”¨,è¿™é‡Œ`lock()` æˆå‘˜å‡½æ•°çš„ä»£ç å¦‚ä¸‹:
```c++
void lock() { // lock the mutex
    _Validate();
    _Pmtx->lock();
    _Owns = true;
}
```
ä¹Ÿå°±æ˜¯é¦–å…ˆæ ¡éªŒåˆç†æ€§,ä¹‹åä¸Šé”,æœ€åè·å–äº’æ–¥ä½“çš„æ‰€æœ‰æƒ , æœ€åæ˜¯ææ„å‡½æ•°,åªæœ‰åœ¨è·å–åˆ°äº’æ–¥ä½“æ‰€æœ‰æƒä¹‹åæ‰å¯ä»¥è§£é”:
```c++
~unique_lock() noexcept {
    if (_Owns) {
        _Pmtx->unlock();
    }
}
```
è¿™é‡Œå¦‚æœåˆ©ç”¨`std::adopt_lock`åªæ˜¯ä¸ä¸Šé”,ä½†æ˜¯è¿˜æ˜¯ä¼šè·å–åˆ°æ‰€æœ‰æƒåˆ©,ä¹Ÿå°±æ˜¯`_Owns`è®¾ç½®ä¸º`true` , ä»è€Œå¯¼å¸ˆ`_Validate()`å‡½æ•°æŠ›å‡ºå¼‚å¸¸
```c++
void _Validate() const { // check if the mutex can be locked
    if (!_Pmtx) {
        _Throw_system_error(errc::operation_not_permitted);
    }

    if (_Owns) {
        _Throw_system_error(errc::resource_deadlock_would_occur);
    }
}
```
æ€»ç»“:
- ä½¿ç”¨`std::defer_lock` æ„é€ å‡½æ•°ä¸ä¸Šé”,è¦æ±‚æ„é€ ä¹‹åä¸Šé”
- ä½¿ç”¨`std::adopt_lock` æ„é€ å‡½æ•°ä¸ä¸Šé”,è¦æ±‚æ„é€ ä¹‹å‰ä¸Šé”
- é»˜è®¤æ„é€ ä¼šä¸Šé”,è¦æ±‚æ„é€ å‡½æ•°ä¹‹å‰å’Œæ„é€ å‡½æ•°ä¹‹åéƒ½ä¸å†æ¬¡ä¸Šé”
åŒæ—¶,`std::unique_lock`çš„çµæ´»ä¹‹å¤„åœ¨äºæ‹¥æœ‰`lock`å’Œ`unlock`æˆå‘˜å‡½æ•°,æ‰€ä»¥ä¸éœ€è¦å’Œ`lock_guard`ä¸€æ ·ä½¿ç”¨ä½œç”¨åŸŸé™,æ‰€ä»¥å¯ä»¥å†™å‡ºå¦‚ä¸‹ä»£ç :
```c++
void f() {
    //code..
    
    std::unique_lock<std::mutex> lock{ m };

    // æ¶‰åŠå…±äº«èµ„æºçš„ä¿®æ”¹çš„ä»£ç ...

    lock.unlock(); // è§£é”å¹¶é‡Šæ”¾æ‰€æœ‰æƒï¼Œææ„å‡½æ•°ä¸ä¼šå† unlock()

    //code..
}
```
å¯ä¼˜å…ˆè€ƒè™‘`lock_guard`ï¼Œä½†æ˜¯å½“æ— æ³•æ»¡è¶³è¦æ±‚çš„æ—¶å€™å¯ä»¥ä½¿ç”¨`std::unique_lock`
#### ä¸åŒä½œç”¨åŸŸä¼ é€’äº’æ–¥é‡
- è¿™é‡Œéœ€è¦ä½¿ç”¨åˆ°ç§»åŠ¨è¯­ä¹‰,è°ƒç”¨`std::unique_lock`çš„ç§»åŠ¨æ„é€ å‡½æ•°,ä¾‹å­å¦‚ä¸‹:
```c++
std::unique_lock<std::mutex> get_lock(){
    extern std::mutex some_mutex;
    std::unique_lock<std::mutex> lk{ some_mutex };
    return lk;
}
void process_data(){
    std::unique_lock<std::mutex> lk{ get_lock() };
    // æ‰§è¡Œä¸€äº›ä»»åŠ¡...
}
```
è¿™é‡Œçš„`extern`åªæ˜¯ä¸€ä¸ªå£°æ˜,åœ¨å…¶ä»–çš„åœ°æ–¹æœ‰å®ƒçš„å®šä¹‰,å¯ä»¥å¤–éƒ¨é“¾æ¥
## ä¿æŠ¤å…±äº«æ•°æ®
### ä¿æŠ¤å…±äº«æ•°æ®çš„åˆå§‹åŒ–è¿‡ç¨‹
- å¹¶éä¿æŠ¤å…±äº«æ•°æ®ä¸€å®šéœ€è¦ä½¿ç”¨äº’æ–¥é”,å¯¹äºå…±äº«æ•°æ®çš„åˆå§‹åŒ–é˜¶æ®µ,å¯ä»¥ä½¿ç”¨å„ç§ä¿æŠ¤æ–¹å¼,åŒ…æ‹¬:  åŒæ ¡éªŒ(é”™è¯¯çš„) , ä½¿ç”¨ `std::call_once` , é™æ€å˜é‡åˆå§‹åŒ–ä»`C++11`å¼€å§‹æ˜¯çº¿ç¨‹å®‰å…¨çš„'
#### åŒéªŒé”(çº¿ç¨‹ä¸å®‰å…¨çš„)
- åŒéªŒé”çš„å®ç°æ–¹å¼å¦‚ä¸‹:
```c++
void f(){
    if(!ptr){      // 1
        std::lock_guard<std::mutex> lk{ m };
        if(!ptr){  // 2
            ptr.reset(new some);  // 3
        }
    }
    ptr->do_something();  // 4
}
```
è¿™é‡Œçš„`ptr.set(new some)` å¹¶éä¸€æ¡åŸå­è¯­å¥,æ‰€ä»¥å½“ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œåˆ°è¿™ä¸€æ¡è¯­å¥çš„æ—¶å€™,å¦‚æœå¦å¤–ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œåˆ°`1`,æ­¤æ—¶æ¡ä»¶ä¸æˆç«‹,å°±ä¼šæ‰§è¡Œ`4`,ä½†æ˜¯ç”±äºå¯¹è±¡è¿˜æ²¡æœ‰æ„å»ºå¥½,æ‰€ä»¥é€ æˆç©ºæŒ‡é’ˆå¼‚å¸¸
#### std::call_once
- `std::call_once` éœ€è¦æ­é… `std::once_flag` ä¸€èµ·ä½¿ç”¨,å…¶ä¸­`std::once_flag` æ˜¯å…¨å±€å‘½åç©ºé—´ä½œç”¨åŸŸå£°æ˜,å¦‚æœæœ‰éœ€è¦,å¯ä»¥æ˜¯ç±»çš„æˆå‘˜,è¿™ä¸€ä¸ªå‡½æ•°å¯ä»¥ä¿è¯çº¿ç¨‹å®‰å…¨çš„ä¸€æ¬¡åˆå§‹åŒ–è°ƒç”¨,å¹¶ä¸”åœ¨å¤šæ¬¡åˆå§‹åŒ–çš„æ—¶å€™ä¼šåªè°ƒç”¨ä¸€æ¬¡(ä¸`once_flag`æœ‰å…³)
```c++
#include <exception>
#include<iostream>
#include<thread>
#include<mutex>
using namespace std;
int n ;
once_flag flag;
once_flag flag2;
void f1() {
    call_once(
            flag , [] {
                n ++;
                cout << "ç¬¬ " << n << " æ¬¡è°ƒç”¨" << endl;
            }
    );
}

void f2() {
    call_once(
            flag2 , [] {
                n ++;
                cout << "ç¬¬ " << n << " æ¬¡è°ƒç”¨" << endl;
            }
    );
}

int main() {
   try {
       f1();
   } catch(exception& e) {
       cout << "å¼‚å¸¸1..." << endl;
   }


   try {
        f2();
   } catch(exception& e) {
       cout << "å¼‚å¸¸2..." << endl;
   }

   cout << "åˆå§‹åŒ–ä¹‹å n = " << n << endl;
}
```
#### é™æ€å±€éƒ¨å˜é‡åˆå§‹åŒ–åœ¨C++11ä¸­æ˜¯çº¿ç¨‹å®‰å…¨
- å¯¹äºé™æ€å±€éƒ¨å˜é‡çš„åˆå§‹åŒ–,åœ¨`C++11`ä¸­å·²ç»æ˜¯çº¿ç¨‹å®‰å…¨çš„äº†,å…¶ä»–çº¿ç¨‹ä¼šç­‰å¾…åˆå§‹åŒ–å®Œæˆ
```c++
class my_class;
inline my_class& get_my_class_instance(){
    static my_class instance;  // çº¿ç¨‹å®‰å…¨çš„åˆå§‹åŒ–è¿‡ç¨‹ åˆå§‹åŒ–ä¸¥æ ¼å‘ç”Ÿä¸€æ¬¡
    return instance;
}
```
### ä¿æŠ¤ä¸å¸¸æ›´æ–°çš„æ•°æ®ç»“æ„
- `C++14`ä¸­æä¾›çš„è¯»å†™é”: `std::shared_timed_lock` , `C++17`ä¸­æä¾›äº†è¯»å†™é”: `std::shared_lock` ,ä½¿ç”¨ä¸¾ä¾‹å¦‚ä¸‹:
```c++
#include<iostream>
#include <shared_mutex>
#include<thread>
#include<mutex>
#include<vector>
using namespace std;

vector<int> vec;  // å…±äº«æ•°æ®
mutex m;
shared_mutex sm;

void writeInVec(int i) {
    lock_guard<mutex> l1{m};
    vec.push_back(i); 
    cout << "write thread write " << i << " into vector!" << endl;
}

void readInVec() {
    int res;
    lock_guard<shared_mutex> l1(sm);
    res = vec.back();
    /*cout << "read thread read: " << vec.back() << endl;*/
}


int main() {
    vec.push_back(1);
    vector<thread> writers;
    for(int i = 0 ; i < 10 ; i ++) {
        writers.emplace_back(writeInVec , i);
    }

    vector<thread> readers;
    for(int i = 0 ; i < 10 ; i ++) {
        readers.emplace_back(readInVec);
    }
    
    for(int i = 0 ; i < 10 ; i ++) {
        writers[i].join();
        readers[i].join();
    }
}
```
### std::recursive_mutex
- `C++` æ ‡å‡†åº“æä¾›çš„ä¸€ç§äº’æ–¥é‡ç±»å‹,å…è®¸åŒä¸€ä¸ªçº¿ç¨‹å¤šæ¬¡é”å®šåŒä¸€ä¸ªäº’æ–¥é‡,è€Œä¸ä¼šé€ æˆæ­»é”,å½“åŒä¸€ä¸ªçº¿ç¨‹å¤šæ¬¡å¯¹åŒä¸€ä¸ª`std::recursive_mutex`è¿›è¡Œé”å®šæ—¶,åªæœ‰è§£é”å’Œé”å®šæ¬¡æ•°ç›¸åŒ¹é…çš„æ—¶å€™,äº’æ–¥é‡æ‰å¯ä»¥çœŸæ­£é‡Šæ”¾,ä¸¾ä¾‹å¦‚ä¸‹:
```c++
/* std::recursive_mutex åŸºæœ¬ä½¿ç”¨ */
#include<iostream>
#include<thread>
#include<mutex>
using namespace std;

recursive_mutex mtx;

void recursive_function(int count) {
    mtx.lock();
    cout << "Locked by thread: " << std::this_thread::get_id()  << " , count = " << count << endl;   
    if(count > 0) {
        recursive_function(count - 1);
    }
    mtx.unlock();
}


int main() {
    thread t1{recursive_function , 3}; 
    thread t2{recursive_function , 2};

    t1.join();
    t2.join();
}
```
å¿…é¡»`lock`å’Œ`unlock`çš„æ¬¡æ•°ä¸€æ ·æ‰å¯ä»¥é‡Šæ”¾é”,æˆ‘ä»¬åŒæ ·å¯ä»¥ä½¿ç”¨ `std::lock_guard` , `std::unique_lock` , `std::recursive_mutex` , è€Œä¸æ˜¯æ˜¾å¼è°ƒç”¨`lock`å’Œ`unlock`
## è¡¥å……å†…å®¹
### new å’Œ delete çš„çº¿ç¨‹å®‰å…¨æ€§
- `C++11`ä¸­ä¿è¯äº†: `operator new` å’Œ `operator delete` çš„çº¿ç¨‹å®‰å…¨æ€§ , ä»`C++17`å¼€å§‹`std::calloc`  , `std::malloc` , `std::realloc` , `std::align_alloc`å’Œ`std::free` ç­‰éƒ½æ˜¯çº¿ç¨‹å®‰å…¨çš„
åŒæ—¶éœ€è¦æ³¨æ„:
- æ€»è€Œè¨€ä¹‹ï¼Œ`new`Â è¡¨è¾¾å¼çº¿ç¨‹å®‰å…¨è¦è€ƒè™‘ä¸‰æ–¹é¢ï¼š`operator new`ã€æ„é€ å‡½æ•°ã€ä¿®æ”¹æŒ‡é’ˆã€‚
- `delete`Â è¡¨è¾¾å¼çº¿ç¨‹å®‰å…¨è€ƒè™‘ä¸¤æ–¹é¢ï¼š`operator delete`ã€ææ„å‡½æ•°ã€‚
### çº¿ç¨‹å­˜å‚¨æœŸ(thread_local)
çº¿ç¨‹å­˜å‚¨æœŸ,ç±»ä¼¼äº`JAVA`ä¸­çš„`ThreadLocal` , ä½†æ˜¯è¿™é‡Œçš„`thread_local`æ›´åƒæ˜¯ä¸€ä¸ªä¿®é¥°ç¬¦å·,ç±»ä¼¼äºæŠŠå˜é‡å­˜å‚¨åœ¨çº¿ç¨‹æ ˆä¸­,ä½¿ç”¨å®ä¾‹å¦‚ä¸‹:
```c++
/* C++ ä¸­çš„çº¿ç¨‹å­˜å‚¨æœŸ */
#include<iostream>
#include<thread>
using namespace std;

int global_counter = 0;
thread_local int thread_local_counter = 0;

void print_counters() {
    cout << "global: " << global_counter++ << endl; 
    cout << "thread_local: " << thread_local_counter++ << endl;
}

int main() {
    thread{print_counters}.join();
    thread{print_counters}.join();
}
```

### å±€éƒ¨,å…¨å±€,çº¿ç¨‹,CPUå˜é‡çš„å¯¹æ¯”ä¸ä½¿ç”¨
- å±€éƒ¨å˜é‡é€‚åˆä¸´æ—¶æ•°æ®ï¼Œä½œç”¨åŸŸç»“æŸè‡ªåŠ¨é‡Šæ”¾ï¼Œå‡ ä¹æ— éœ€åŒæ­¥ã€‚
- å…¨å±€å˜é‡é€‚åˆæ•´ä¸ªç¨‹åºçš„å…±äº«çŠ¶æ€ï¼Œä½†éœ€è¦ä½¿ç”¨åŒæ­¥è®¾æ–½è¿›è¡Œä¿æŠ¤ã€‚
- çº¿ç¨‹å˜é‡é€‚åˆçº¿ç¨‹çš„ç‹¬ç«‹çŠ¶æ€ï¼Œé€šå¸¸æ— éœ€åŒæ­¥ã€‚
- `CPU` å˜é‡çš„ä½¿ç”¨æ˜¯å°‘è§çš„ï¼Œä¸»è¦ç”¨äºå†…æ ¸å¼€å‘å’Œè¿½æ±‚æè‡´æ€§èƒ½çš„é«˜å¹¶å‘åœºæ™¯ï¼Œå‡å°‘ `CPU` åŒæ­¥å¼€é”€ã€‚