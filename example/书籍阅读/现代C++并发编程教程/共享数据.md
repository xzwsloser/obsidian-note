> 主要解决多个线程在操作同一份共享数据时产生的线程安全问题

当某个表达式的求值写入某个内存位置，而另一求值读或修改同一内存位置时，称这些**表达式冲突**。**拥有两个冲突的求值的程序就有数据竞争**，除非
- 两个求值都在同一线程上，或者在同一信号处理函数中执行，或
- 两个冲突的求值都是原子操作（见 `std::atomic`），或
- 一个冲突的求值发生早于 另一个（见 `std::memory_order`）
下面介绍解决竞争导致的线程安全问题的方法
## 使用互斥量
### std::mutex
- `std::mutex` 为互斥锁,可以用于保护共享数据,解决线程安全问题,使用举例如下:
```c++
#include<iostream>
#include<thread>
#include<mutex>
#include<vector>

using namespace std;
mutex m;

int main() {
    auto f = [](int i) {
        m.lock();
        cout << "thread: "  << this_thread::get_id() << " get: " << i << endl;   
        m.unlock();
    }; 

    vector<thread> threads;
    for(int i = 0 ; i < 10 ; i ++) {
        threads.emplace_back(f , i);
    }

    for(auto& t : threads) {
         if(t.joinable()) {
            t.join();
         }
    }
}
```
### std::lock_guard
- 使用了 `RAII` 思想,把互斥锁的解锁和对象的析构函数联系起来了
- 拥有两个构造函数:
```c++
explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) {
	_MyMutex.lock(); 
} 
lock_guard(_Mutex& _Mtx, adopt_lock_t) noexcept: _MyMutex(_Mtx) {} // construct but don't lock
```
- 上面一个构造函数在管理互斥锁之后会上锁,如果原来的互斥锁上锁了,就会形成死锁,后面一个需要提前上锁,离开`lock_guard`作用域之后解锁(不需要自己解锁)
- 举例如下:
```c++
#include <chrono>
#include<iostream>
#include<thread>
#include<vector>
#include<mutex>
using namespace std;

mutex m;
int main() {
    auto f = [](int i) {
            m.lock();
             {
                lock_guard<mutex> l{m , adopt_lock};
                cout << "是否正常打印" << i << endl;
             }
             this_thread::sleep_for(chrono::seconds(10 - i));
             cout << "hello" << i << endl;
               /*cout << "thread: " << this_thread::get_id() << " get: " << i << endl;*/
    };

    vector<thread> threads;
    for(int i = 0 ; i < 10 ; i ++) {
        threads.emplace_back(f , i);
    }

    for(auto& t : threads) {
        if(t.joinable()) {
            t.join();
        }
    }
}
```
### try_lock
- `try_lock` 会尝试上锁,但是如果锁已经被其他的线程占用了,就不会阻塞当前线程,而是直接返回,返回类型为 `bool` , 上锁成功就返回`true` , 否则返回 `false`,举例如下:
```c++
std::mutex mtx;

void thread_function(int id) {
    // 尝试加锁
    if (mtx.try_lock()) {
        std::cout << "线程：" << id << " 获得锁" << std::endl;
        // 临界区代码
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟临界区操作
        mtx.unlock(); // 解锁
        std::cout << "线程：" << id << " 释放锁" << std::endl;
    } else {
        std::cout << "线程：" << id << " 获取锁失败 处理步骤" << std::endl;
    }
}
```
## 保护共享数据
- 保护共享数据的一种准则: 只能在受互斥锁保护的区域里面使用共享数据 , 尽量不要吧共享数据以引用的方式传递给外界,否则就可能使得外界也可以访问共享数据
## 死锁
### 死锁的原因
- 多个互斥量才可能遇到死锁问题,比如对于临界区的访问加上多把锁,但是锁的顺序不正确,举例如下:
```c++
#include <chrono>
#include<thread>
#include<mutex>
#include<vector>
using namespace std;

mutex m1 , m2;
int n;

void func1() {
    lock_guard<mutex> l1{m1};
    this_thread::sleep_for(chrono::seconds(2));
    lock_guard<mutex> l2{m2};
    ++n;
}

void func2() {
    lock_guard<mutex> l1{m2};
    lock_guard<mutex> l2{m1};
    ++n;
}

int main() {
    n = 0;
    vector<thread> f1s;
    for(int i = 0 ; i < 5 ; i ++) {
        f1s.emplace_back(func1);
    }

    vector<thread> f2s;
    for(int i = 0 ; i < 5 ; i ++) {
        f2s.emplace_back(func2);
    }

    for(int i = 0 ; i < 5 ; i ++) {
        f1s[i].join();
        f2s[i].join();
    }
}
```
同时也有很多值得注意的细节,比如在下图中,由于传入的参数不同,最后可能导致死锁:
```c++
struct X{
    X(const std::string& str) :object{ str } {}

    friend void swap(X& lhs, X& rhs);
private:
    std::string object;
    std::mutex m;
};

void swap(X& lhs, X& rhs) {
    if (&lhs == &rhs) return;
    std::lock_guard<std::mutex> lock1{ lhs.m }; 
    std::lock_guard<std::mutex> lock2{ rhs.m }; 
    swap(lhs.object, rhs.object);
}

// 导致死锁的测试代码:
X a{ "🤣" }, b{ "😅" };
std::thread t{ [&] {swap(a, b); } };  // 1
std::thread t2{ [&] {swap(b, a); } }; // 2
```