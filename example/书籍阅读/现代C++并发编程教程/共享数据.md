> ä¸»è¦è§£å†³å¤šä¸ªçº¿ç¨‹åœ¨æ“ä½œåŒä¸€ä»½å…±äº«æ•°æ®æ—¶äº§ç”Ÿçš„çº¿ç¨‹å®‰å…¨é—®é¢˜

å½“æŸä¸ªè¡¨è¾¾å¼çš„æ±‚å€¼å†™å…¥æŸä¸ªå†…å­˜ä½ç½®ï¼Œè€Œå¦ä¸€æ±‚å€¼è¯»æˆ–ä¿®æ”¹åŒä¸€å†…å­˜ä½ç½®æ—¶ï¼Œç§°è¿™äº›**è¡¨è¾¾å¼å†²çª**ã€‚**æ‹¥æœ‰ä¸¤ä¸ªå†²çªçš„æ±‚å€¼çš„ç¨‹åºå°±æœ‰æ•°æ®ç«äº‰**ï¼Œé™¤é
- ä¸¤ä¸ªæ±‚å€¼éƒ½åœ¨åŒä¸€çº¿ç¨‹ä¸Šï¼Œæˆ–è€…åœ¨åŒä¸€ä¿¡å·å¤„ç†å‡½æ•°ä¸­æ‰§è¡Œï¼Œæˆ–
- ä¸¤ä¸ªå†²çªçš„æ±‚å€¼éƒ½æ˜¯åŸå­æ“ä½œï¼ˆè§ `std::atomic`ï¼‰ï¼Œæˆ–
- ä¸€ä¸ªå†²çªçš„æ±‚å€¼å‘ç”Ÿæ—©äºâ€Šå¦ä¸€ä¸ªï¼ˆè§ `std::memory_order`ï¼‰
ä¸‹é¢ä»‹ç»è§£å†³ç«äº‰å¯¼è‡´çš„çº¿ç¨‹å®‰å…¨é—®é¢˜çš„æ–¹æ³•
## ä½¿ç”¨äº’æ–¥é‡
### std::mutex
- `std::mutex` ä¸ºäº’æ–¥é”,å¯ä»¥ç”¨äºä¿æŠ¤å…±äº«æ•°æ®,è§£å†³çº¿ç¨‹å®‰å…¨é—®é¢˜,ä½¿ç”¨ä¸¾ä¾‹å¦‚ä¸‹:
```c++
#include<iostream>
#include<thread>
#include<mutex>
#include<vector>

using namespace std;
mutex m;

int main() {
    auto f = [](int i) {
        m.lock();
        cout << "thread: "  << this_thread::get_id() << " get: " << i << endl;   
        m.unlock();
    }; 

    vector<thread> threads;
    for(int i = 0 ; i < 10 ; i ++) {
        threads.emplace_back(f , i);
    }

    for(auto& t : threads) {
         if(t.joinable()) {
            t.join();
         }
    }
}
```
### std::lock_guard
- ä½¿ç”¨äº† `RAII` æ€æƒ³,æŠŠäº’æ–¥é”çš„è§£é”å’Œå¯¹è±¡çš„ææ„å‡½æ•°è”ç³»èµ·æ¥äº†
- æ‹¥æœ‰ä¸¤ä¸ªæ„é€ å‡½æ•°:
```c++
explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) {
	_MyMutex.lock(); 
} 
lock_guard(_Mutex& _Mtx, adopt_lock_t) noexcept: _MyMutex(_Mtx) {} // construct but don't lock
```
- ä¸Šé¢ä¸€ä¸ªæ„é€ å‡½æ•°åœ¨ç®¡ç†äº’æ–¥é”ä¹‹åä¼šä¸Šé”,å¦‚æœåŸæ¥çš„äº’æ–¥é”ä¸Šé”äº†,å°±ä¼šå½¢æˆæ­»é”,åé¢ä¸€ä¸ªéœ€è¦æå‰ä¸Šé”,ç¦»å¼€`lock_guard`ä½œç”¨åŸŸä¹‹åè§£é”(ä¸éœ€è¦è‡ªå·±è§£é”)
- ä¸¾ä¾‹å¦‚ä¸‹:
```c++
#include <chrono>
#include<iostream>
#include<thread>
#include<vector>
#include<mutex>
using namespace std;

mutex m;
int main() {
    auto f = [](int i) {
            m.lock();
             {
                lock_guard<mutex> l{m , adopt_lock};
                cout << "æ˜¯å¦æ­£å¸¸æ‰“å°" << i << endl;
             }
             this_thread::sleep_for(chrono::seconds(10 - i));
             cout << "hello" << i << endl;
               /*cout << "thread: " << this_thread::get_id() << " get: " << i << endl;*/
    };

    vector<thread> threads;
    for(int i = 0 ; i < 10 ; i ++) {
        threads.emplace_back(f , i);
    }

    for(auto& t : threads) {
        if(t.joinable()) {
            t.join();
        }
    }
}
```
### try_lock
- `try_lock` ä¼šå°è¯•ä¸Šé”,ä½†æ˜¯å¦‚æœé”å·²ç»è¢«å…¶ä»–çš„çº¿ç¨‹å ç”¨äº†,å°±ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹,è€Œæ˜¯ç›´æ¥è¿”å›,è¿”å›ç±»å‹ä¸º `bool` , ä¸Šé”æˆåŠŸå°±è¿”å›`true` , å¦åˆ™è¿”å› `false`,ä¸¾ä¾‹å¦‚ä¸‹:
```c++
std::mutex mtx;

void thread_function(int id) {
    // å°è¯•åŠ é”
    if (mtx.try_lock()) {
        std::cout << "çº¿ç¨‹ï¼š" << id << " è·å¾—é”" << std::endl;
        // ä¸´ç•ŒåŒºä»£ç 
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // æ¨¡æ‹Ÿä¸´ç•ŒåŒºæ“ä½œ
        mtx.unlock(); // è§£é”
        std::cout << "çº¿ç¨‹ï¼š" << id << " é‡Šæ”¾é”" << std::endl;
    } else {
        std::cout << "çº¿ç¨‹ï¼š" << id << " è·å–é”å¤±è´¥ å¤„ç†æ­¥éª¤" << std::endl;
    }
}
```
## ä¿æŠ¤å…±äº«æ•°æ®
- ä¿æŠ¤å…±äº«æ•°æ®çš„ä¸€ç§å‡†åˆ™: åªèƒ½åœ¨å—äº’æ–¥é”ä¿æŠ¤çš„åŒºåŸŸé‡Œé¢ä½¿ç”¨å…±äº«æ•°æ® , å°½é‡ä¸è¦å§å…±äº«æ•°æ®ä»¥å¼•ç”¨çš„æ–¹å¼ä¼ é€’ç»™å¤–ç•Œ,å¦åˆ™å°±å¯èƒ½ä½¿å¾—å¤–ç•Œä¹Ÿå¯ä»¥è®¿é—®å…±äº«æ•°æ®
## æ­»é”
### æ­»é”çš„åŸå› 
- å¤šä¸ªäº’æ–¥é‡æ‰å¯èƒ½é‡åˆ°æ­»é”é—®é¢˜,æ¯”å¦‚å¯¹äºä¸´ç•ŒåŒºçš„è®¿é—®åŠ ä¸Šå¤šæŠŠé”,ä½†æ˜¯é”çš„é¡ºåºä¸æ­£ç¡®,ä¸¾ä¾‹å¦‚ä¸‹:
```c++
#include <chrono>
#include<thread>
#include<mutex>
#include<vector>
using namespace std;

mutex m1 , m2;
int n;

void func1() {
    lock_guard<mutex> l1{m1};
    this_thread::sleep_for(chrono::seconds(2));
    lock_guard<mutex> l2{m2};
    ++n;
}

void func2() {
    lock_guard<mutex> l1{m2};
    lock_guard<mutex> l2{m1};
    ++n;
}

int main() {
    n = 0;
    vector<thread> f1s;
    for(int i = 0 ; i < 5 ; i ++) {
        f1s.emplace_back(func1);
    }

    vector<thread> f2s;
    for(int i = 0 ; i < 5 ; i ++) {
        f2s.emplace_back(func2);
    }

    for(int i = 0 ; i < 5 ; i ++) {
        f1s[i].join();
        f2s[i].join();
    }
}
```
åŒæ—¶ä¹Ÿæœ‰å¾ˆå¤šå€¼å¾—æ³¨æ„çš„ç»†èŠ‚,æ¯”å¦‚åœ¨ä¸‹å›¾ä¸­,ç”±äºä¼ å…¥çš„å‚æ•°ä¸åŒ,æœ€åå¯èƒ½å¯¼è‡´æ­»é”:
```c++
struct X{
    X(const std::string& str) :object{ str } {}

    friend void swap(X& lhs, X& rhs);
private:
    std::string object;
    std::mutex m;
};

void swap(X& lhs, X& rhs) {
    if (&lhs == &rhs) return;
    std::lock_guard<std::mutex> lock1{ lhs.m }; 
    std::lock_guard<std::mutex> lock2{ rhs.m }; 
    swap(lhs.object, rhs.object);
}

// å¯¼è‡´æ­»é”çš„æµ‹è¯•ä»£ç :
X a{ "ğŸ¤£" }, b{ "ğŸ˜…" };
std::thread t{ [&] {swap(a, b); } };  // 1
std::thread t2{ [&] {swap(b, a); } }; // 2
```