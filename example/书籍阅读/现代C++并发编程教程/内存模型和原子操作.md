> 介绍内存模型和原子操作
- 内存模型定义了多线程程序中,读写操作如何在不同线程之间可见,以及这些操作在和中顺序下执行,内存模型确保程序的行为在并发环境下是不可预测的
- 原子操作即不可分割的操作,系统所有的线程不可能观察到原子操作完成了一半(可以吧原子指令理解为一条汇编指令)
## 原子类型 `std::atomic`
原子类型的实现可以基于锁或者基于无锁实现(比如`CAS`) ,  每一个原子类型中都含有一个`is_lock_free`成员函数,表示是否是使用无锁技术实现的,并且在`C++17`中引入了静态成员 `static constexpr`数据成员: `is_always_lock_free`,如果当前环境类型为无锁类型,就会返回`true` ,并且提供了一组宏定义在编译时对于各种整数原子类型是否无锁进行判断:
```C++
// (C++11 起)
#define ATOMIC_BOOL_LOCK_FREE     /* 未指定 */
#define ATOMIC_CHAR_LOCK_FREE     /* 未指定 */
#define ATOMIC_CHAR16_T_LOCK_FREE /* 未指定 */
#define ATOMIC_CHAR32_T_LOCK_FREE /* 未指定 */
#define ATOMIC_WCHAR_T_LOCK_FREE  /* 未指定 */
#define ATOMIC_SHORT_LOCK_FREE    /* 未指定 */
#define ATOMIC_INT_LOCK_FREE      /* 未指定 */
#define ATOMIC_LONG_LOCK_FREE     /* 未指定 */
#define ATOMIC_LLONG_LOCK_FREE    /* 未指定 */
#define ATOMIC_POINTER_LOCK_FREE  /* 未指定 */
// (C++20 起)
#define ATOMIC_CHAR8_T_LOCK_FREE  /* 未指定 */
```
可以利用预处理指令来判断当前环境是否无锁,宏定义的值和是否有锁的关系如下:
- 对于一定有锁的内建原子类型是 `0`
- 对于有时无锁的内建原子类型是 `1`
- 对于一定无锁的内建原子类型是 `2` 
```c++
/*  利用预处理指令来确定是否利用锁实现 std::atomic  */
#include<iostream>
#include<atomic>
using namespace std;


int main() {

    if constexpr(atomic<int>::is_always_lock_free) {
        cout << "当前环境 std::atomic<int> 始终无锁 " << endl;
    } else {
        cout << "当前环境 std::atomic<int> 并非无锁 " << endl;
    }

#if ATOMIC_INT_LOCK_FREE == 2
    cout << "int 类型的原子变量一定是无锁的 " << endl;
#elif ATOMIC_INT_LOCK_FREE == 1
    cout << "int 类型的原子变量有时是无锁的 " << endl;
#else 
    cout << "int 类型的原子变量一定是有锁的 " << endl;
#endif
}
```
注意上面使用了`C++17`特性: `if constexpr`, 可以在编译时期进行判断
另外除了使用原子变量本身之外还可以使用原子类型的别名,别名类型如下(其实不使用别名感觉还好记一些):
```c++
using atomic_char   = atomic<char>;
using atomic_schar  = atomic<signed char>;
using atomic_uchar  = atomic<unsigned char>;
using atomic_short  = atomic<short>;
using atomic_ushort = atomic<unsigned short>;
using atomic_int    = atomic<int>;
using atomic_uint   = atomic<unsigned int>;
using atomic_long   = atomic<long>;
using atomic_ulong  = atomic<unsigned long>;
using atomic_llong  = atomic<long long>;
using atomic_ullong = atomic<unsigned long long>;
```
虽然原子变量不可以移动,但是可以通过隐式转换成对应的内置类型,这是由于它具有转换函数,定义如下:
```c++
atomic(const atomic&) = delete;
atomic& operator=(const atomic&) = delete;
operator T() const noexcept;  // 转换函数
```
并且可以使用 `load()` , `store()` , `exchange()` , `compare_exchange_weak()` 和 `compare_exchange_strong()` 等成员函数对于 `std::atomic`进行操作,如果是整数类型年还支持,各种运算符操作,比如 `++ -- += -= &= |= ^= ` , `fetch_add`,`fetch_sub`等操作方式 , 同时自定义类型也可以创建对应的原子对象,不过由于是通用模板,操作仅限于 `load() ...`等,比如利用元自变量来操作自定义类型的方法如下:
```c++
/* 原子类型操作自定义类型 */
#include <future>
#include<iostream>
#include<atomic>
using namespace std;

struct trivial_type {
    int x{};
    float y{};

    trivial_type() {}

    trivial_type(int a, float b) : x{ a }, y{ b } {}

    trivial_type(const trivial_type& other) = default;

    trivial_type& operator=(const trivial_type& other) = default;

    ~trivial_type() = default;
};

int main() {
    atomic<trivial_type> atomic_my_type {trivial_type{10 , 20.5f}};    
    trivial_type new_value {30 , 40.5f};
    atomic_my_type.store(new_value);
    trivial_type loadedValue = atomic_my_type.load();
    cout << "x = " << loadedValue.x << " y = " << loadedValue.y << endl;
    // 使用 exchange 操作 
    trivial_type exchanged_value = atomic_my_type.exchange(trivial_type{50 , 60.5f});
    cout << "交换之前 x = " << exchanged_value.x << " 交换之前 y = " << exchanged_value.y << endl;  
    cout << "交换之后 x = " << atomic_my_type.load().x << " 交换之后 y = " << atomic_my_type.load().y << endl;
}
```
感觉`atomic<T>`存储一个数字,利用`exchange`可以把数字交换进去(好像这才是正确的理解),当成一个普通的类型只是支持原子操作而已

注意每一个原子操作的每一个操作函数都有一个内存序参数,用于指定执行顺序,操作的类型分为如下三种:

1. **Store 操作（存储操作）**：可选的内存序包括 `memory_order_relaxed`、`memory_order_release`、`memory_order_seq_cst`。
2. **Load 操作（加载操作）**：可选的内存序包括 `memory_order_relaxed`、`memory_order_consume`、`memory_order_acquire`、`memory_order_seq_cst`。
3. **Read-modify-write（读-改-写）操作**：可选的内存序包括 `memory_order_relaxed`、`memory_order_consume`、`memory_order_acquire`、`memory_order_release`、`memory_order_acq_rel`、`memory_order_seq_cst`。
并且注意到任何 `std::atomic`类型,初始化都不是原子操作
### `std::atomic_flag`
`std::atomic_flag`是最简单的原子类型,这一个类型的对象可以在两种状态之前切换,设置(`true`)或者清除(`false`)   
初始化方式: 在 `C++20`之后可以使用默认构造函数初始化,之前需要使用 `ATOMIC_FLAG_INIT`宏定义来初始化为清除状态 
















