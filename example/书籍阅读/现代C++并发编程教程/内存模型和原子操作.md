> 介绍内存模型和原子操作
- 内存模型定义了多线程程序中,读写操作如何在不同线程之间可见,以及这些操作在和中顺序下执行,内存模型确保程序的行为在并发环境下是不可预测的
- 原子操作即不可分割的操作,系统所有的线程不可能观察到原子操作完成了一半(可以吧原子指令理解为一条汇编指令)
## 原子类型 `std::atomic`
原子类型的实现可以基于锁或者基于无锁实现(比如`CAS`) ,  每一个原子类型中都含有一个`is_lock_free`成员函数,表示是否是使用无锁技术实现的,并且在`C++17`中引入了静态成员 `static constexpr`数据成员: `is_always_lock_free`,如果当前环境类型为无锁类型,就会返回`true` ,并且提供了一组宏定义在编译时对于各种整数原子类型是否无锁进行判断:
```C++
// (C++11 起)
#define ATOMIC_BOOL_LOCK_FREE     /* 未指定 */
#define ATOMIC_CHAR_LOCK_FREE     /* 未指定 */
#define ATOMIC_CHAR16_T_LOCK_FREE /* 未指定 */
#define ATOMIC_CHAR32_T_LOCK_FREE /* 未指定 */
#define ATOMIC_WCHAR_T_LOCK_FREE  /* 未指定 */
#define ATOMIC_SHORT_LOCK_FREE    /* 未指定 */
#define ATOMIC_INT_LOCK_FREE      /* 未指定 */
#define ATOMIC_LONG_LOCK_FREE     /* 未指定 */
#define ATOMIC_LLONG_LOCK_FREE    /* 未指定 */
#define ATOMIC_POINTER_LOCK_FREE  /* 未指定 */
// (C++20 起)
#define ATOMIC_CHAR8_T_LOCK_FREE  /* 未指定 */
```
可以利用预处理指令来判断当前环境是否无锁