> 书中对于并发问题的引入举了一个比较有意思的例子: 当多个人共享同一个桃子的时候,所有人首先在视觉上看到了桃子,但是当多个人伸手去拿桃子的时候却会惊奇的发现桃子不见了
## 并发引入
- 还是通过经典的线程同步的例子引出并发中线程安全的问题,和`csapp`中一样,把对于共享数据的处理拆分为指令级别的,之后说明在一个线程执行这些指令的过程中,可恶的中断调度其他线程导致线程安全问题,最后提出了各种解决线程安全问题的方式: 提供原子操作指令或者停止屏蔽中断
## 锁
### 锁的定义
- 根据上面的讨论自然而然引出了锁的概念,一个锁其实就是一个变量,这一个变量中可以记录各种各样的信息,比如对于锁的标识,锁的状态甚至可以记录阻塞在锁上面的线程队列等信息
### 评价锁的指标
- 正确性: 是否可以正确的完成互斥的任务
- 公平性: 所有线程都可以拿到锁,放置某些线程因为拿不到产生的饥饿问题
- 性能
### 实现一个锁
- 一般而言,对于操作系统中某一个功能的支持或者某一个操作性能的提升一般都需要操作系统的支持和硬件的支持,硬件的支持主要用于提供各种可以使用的指令,操作系统的支持则是利用硬件提供的各种指令来操作数据结构完成对于操作的优化
#### 硬件支持
- 硬件支持主要是为操作系统各种操作的原子指令(这些指令的实现依赖于底层的数字逻辑结构),如下总结书中提到的几种可以用于实现锁的原子指令
##### 测试并且设置指令
- 测试并且设置指令运行把设置一个内存空间处的值为新的值并且返回旧的值这一个操作作为一个原子指令,相似的原子指令比如`x86`中的`xchg`指令,实现的功能如下:
```c++
int TestAndSet(int* old_ptr , int new) {
	int old = *old_ptr;
	*old_ptr = new;
	return old;
}
```
- 所以依赖于这一个指令,可以利用如下操作实现互斥锁:
![[Pasted image 20241102150859.png]]
- 上面的锁,当线程被阻塞的时候就会不断判断条件并且阻塞等待,这一个过程成为自旋,所以这一个锁被称为自旋锁
- 对于自旋锁的评价:
	- 正确性: 可以保证互斥性
	- 公平性: 自旋的线程会在阻塞处不断自旋占用`CPU`,没有公平性,会导致自旋操作不断占用`CPU`,执行其他任务的线程占用`CPU`的时间减少或者拿不到锁而饿死
	- 性能: 单`CPU`上性能不好,多`CPU`上由于执行任务的线程和自旋的线程可以在不同的`CPU`上面执行所以性能不错
##### 比较并且交换指令
- 指令的伪`C`代码实现:
```c++
int CompareAndSwap(int* ptr , int expected , int new) {
	int actual = *ptr;
	if(actual == expected) 
		*ptr = new;
	return actual;
}
```
- 利用这一条指令实现锁:
![[Pasted image 20241102151552.png]]
- 但是以上实现的还是自旋锁,还是会导致以上的问题
##### 链接的加载和条件式存储指令
- 原子指令的伪`C`代码实现:
![[Pasted image 20241102151753.png]]
- 利用这一条指令实现锁:
![[Pasted image 20241102151950.png]]
##### 获取并且添加指令
- 获取并且添加指令的实现方式如下:
```c++
int FetchAndAdd(int* ptr) {
	int old = *ptr;
	*ptr = old + 1;
	return old;
}
```
- 利用这一条指令可以实现`tickets`锁:
![[Pasted image 20241102152323.png]]
- 以上实现锁的过程保证了每一个尝试的线程都可以获取到锁,保证了公平性
- 最后可以发现如何仅仅依靠硬件层面实现的原子指令来实现锁,那么难以保证自旋过多的问题,所以此时就需要软件(操作系统)支持了
#### 操作系统支持
- 通过操作系统支持,可以提供各种数据结构或者系统调用来控制进程的调度
##### 自旋的时候让出CPU
- 最简单的一种方法: 自旋的时候让出`CPU`:
![[Pasted image 20241102152810.png]]
- 但是利用这一种方式当很多线程同时竞争一把锁的时候就会导致很多线程不断处理礼让-自旋的这一种的状态中,也就是不可以让自旋的进程处于就绪状态
##### 使用队列: 休眠替代自旋
- 一种比较巧妙的方法就是让自旋的线程进入休眠状态,同时所有休眠状态中的线程被放入到队列中,实现方法如下:
![[Pasted image 20241102153342.png]]
- 这一种方法就使得自旋的线程在经过一次条件判断之后都处于休眠状态了,减少了自旋线程对于`CPU`的占用
##### 两阶段锁
- 核心思想: 如果第一个自旋阶段没有获取到锁,第二个阶段调用者就会休眠知道锁可以使用,比如`Linux`中就是使用这一种方式,并且`Linux`中设置自旋次数为`1`:
![[Pasted image 20241102154851.png]]
- 不太明白这一段代码
## 并发的数据结构
- 有了互斥锁之后就可以利用互斥锁构建各种并发安全的数据结构,并且构建这一些数据的结构的时候都可以使用一个非常简单粗暴的方法(对于每一个操作都使用加锁的方式进行互斥),同时注意拓展性,拓展性也就是指在进行某一个操作的时候是否可以并发的操作数据结构的另外的部分,拓展性能的实现方式就是控制更小的锁的力度,比如对于链表,给链表的每一个节点上锁,对于队列,给队列头和队列尾上锁
- 注意锁的语义: 就是保护相应的共享变量,比如对于队列头上的锁就是保护队列头部,里面就是操作头部的代码
- 书中主要介绍了并发的计数器,链表,队列和散列表的数据结构 , 参考书中实现代码即可(也就是注意加锁的粒度即可),另外注意并发计数器的实现方式即可(惊为人天的一种操作)
## 条件变量
- 条件变量的作用: 可以让线程阻塞在某一个条件的位置
- 和锁这样的并发原语一样,条件变量其实也是一个结构,它其实是一个显示队列
- 相关的操作:
```c
pthread_cond_t cond;  // 声明条件变量
int pthread_cond_init(pthread_cond_t *restrict cond,
           const pthread_condattr_t *restrict attr);  // 初始化条件变量
int pthread_cond_destroy(pthread_cond_t *cond);  // 销毁条件变量
int pthread_cond_wait(pthread_cond_t *restrict cond,
           pthread_mutex_t *restrict mutex); // 根据条件阻塞线程
int pthread_cond_signal(pthread_cond_t *cond); // 随机唤醒一个阻塞在条件变量上的一个线程
int pthread_cond_broadcast(pthread_cond_t *cond); // 唤醒阻塞在条件变量上的所有线程
```
- 特别注意,`pthread_cond_signal`的作用如下:
	- 首先会释放互斥锁
	- 阻塞等待条件满足(也就是`pthread_cond_signal`唤醒)
	- 重新获取锁
- 本节中的引入方式就是通过不断完善生产者消费者模型从而引出条件变量的各种特性的,所以这里直接阐述利用条件变量实现生产者消费者模型的注意事项 代码: [[pro_con_cond.c]] 
