> 教育不是注满一桶水,而是点燃一把火

## 10月29日回顾
### 知识回顾
- 看书的过程中发现自己对于`ret`指令和`pushq`指令还有`popq`指令的执行过程有所遗忘,执行过程如下:
- `pushq`和`popq`指令的作用(特别注意`popq`):
![[Pasted image 20241029231200.png]]
- `pushq`指令: 把栈指针向下面移动`8`并且把原来的`rA`中存储的地址存放在内存中,加入`rA`中存储这指令实体,那么利用这一个指令就会导致新的栈指针执行的地址对应在内存中就是这一条指令实体(`attacklab`)(相当于向内存中储存储指令,之前的指令存储在新的栈指针指向的位置)
- `popq`指令: 把栈指针向上面移动`8`并且把原来的栈指针指向的地址实体放入到寄存器`rA`中(完成了从内存到寄存器的映射),这里可以是把内存中的指令取出到寄存器中了(相当于从内存中取出指令,取出之前的指令存储在`rA`中,栈指针也可以存储数据(比如上下文))
- `ret`指令:
![[Pasted image 20241029231827.png]]
- 类似于`pushq`指令,这里从原来的栈顶指针中取出指令并且跳转执行原来栈顶指针指向的指令,也会把栈顶指针`+8`
### 读书感悟
- 本书首先简单介绍了操作系统,根据我的理解操作系统就是硬件和软件的桥梁,对于硬件(比如`CPU`,`内存`,`硬盘`,`IO`设备等),操作系统把硬件的各种资源进行抽象,也就是书中所讲述的虚拟化(接下来的讨论一般来说都是针对于单`CPU`的情况),比如`CPU`只有一个但是需要同时运行多个程序,那么操作系统就使用时分复用的方式在一个很小的时间片段内执行不同的程序这就造成了`CPU`同时执行多个程序的假象,在比如对于内存资源,不同的程序运行的时候就算使用了某种特定的方法使得程序中的某些变量的地址一样,但是对于这个变量的操作却不会相互干扰,这里操作系统对于内存做了虚拟化,制造了单个程序独享内存的假象;另外由于`CPU`同时执行多个程序,所以这就会引发并发的问题,并发的问题在我的理解下就是软件层面的问题,比如多个线程同时访问一个共享变量;最后操作系统还需要持续存储它保存的数据,操作系统必须持久化的保存数据,所以这里就会设计文件系统等,这一个特点成为持久化
- 接下来,讲述了进程的抽象概念,进程就是运行起来的程序,`CPU`通过把程序加载道内存中对于程序进行运行,这一个过程中回首先加载代码片段和数据片段(现代操作系统倾向于懒加载,需要数据才会加载),之后回初始化程序运行时栈和堆并且进行一系列初始化任务
- 之后介绍了进程的状态(注意就绪是没有调度到这一个进程,运行是调度到了这一个进程)
- 接下来介绍了与进程有关的各种`API` , 这就不多说了
- 下面的一些中主要讲述了`CPU`如何运行一个进程,首先提到了不受限制的运行,这就会导致用户进程可以访问系统的所有资源,所以引出了用户模式和内核模式的概念,但是当用户有时候需要访问系统资源(比如接受网络包,存储文件时),就需要转换到内核模式进行调用,所以这里引出了`System call`的概念,系统调用本来是普通的`C`库函数,但是其中利用汇编加入了`trap`指令得以让`CPU`陷入内核模式,从而执行各种操作,这里操作系统启动时加载陷阱表记录着遇到怎样的`trap`需要执行那一种操作
- 接下来就引出了上下文切换的概念,也就是在不同的进程之间进程切换,在此之前还讲述了操作系统如何获得执行权,主要时通过时钟中断的方式,之后加少了保存和恢复上下文的方式,操作系统需要进行调度时,首先把各种寄存器的值存储在该进程的内核栈中(比如`PCB`中,`PCB`中就有存储者各种寄存器的结构体),同时将需要被调度的进程的内核栈中存储的寄存器的值加载道物理寄存器中并且执行该进程,比如相关指令如下:
![[Pasted image 20241029234305.png]]