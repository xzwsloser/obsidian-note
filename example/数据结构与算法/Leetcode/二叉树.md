> 用于记录`Leetcode`中二叉树相关题目的解法,首先最基本的二叉树的前序遍历,中序遍历和后序遍历,层次遍历的迭代实现方式一定需要倒背如流,注意理解转移的顺序即可,另外二叉树的题目一般都可以使用递归法来实现,但是注意递归三要素(递归函数的返回值,递归函数的终止条件,单层递归逻辑),看到一种比较好的统一遍历方式,可以参考以下,感觉总结出来通用的模板了: [统一的迭代法实现](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF)

- [x] 添加统一迭代法代码实现 
- 统一迭代法和层序遍历法实现方式: [[tree.cpp]]
## 常见算法题型
1. 层序遍历:
	1. [层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/) 基本的层序遍历,但是需要记录每一层的节点数目,注意此时需要获取到队列的长度来确定每一层的数量
	2. [层序遍历II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/) 直接层序遍历得到数组并且进行反转即可,但是注意`C++`中的`reverse`算法在反转`vector<vector<T>>` 会反转内层数组的元素,所以这里需要在加入节点的时候首先加入右节点,之后加入左节点(但是我本地没有问题?)
	3. [二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/) 只用在层序遍历的过程中记录最后一个遍历到的节点的值即可
	4. [二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/) 一样的,注意定义`sum`为`double`类型,或者$*0.1$ 来转换为`double`类型
	5. [N叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/) 注意不知道`Node*&`怎么写,可以使用自动类型推导`auto`
	6. [二叉树行中的最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/submissions/574879196/) 同上
	7. [填充每一个节点的下一个节点](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/submissions/574881321/)注意在`C++`中进行指针的赋值操作,其实指针就是存储数据的`int`,所以对于指针指向的变量进行改变的时候,堆区地址指向的变量就会发生改变,所以指针可以起到关联更新的作用
	8. [填充每一个节点的下一个节点II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)  和上面一个样,如果需要进行从右边到左边的连接,就可以使用首先加入右边的节点,之后加入左边的节点
	9. [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/574885084/) 注意层次遍历就是一种`bfs`,所以可以利用`bfs`进行最小路径的寻找,这一个题目就是一个例子
