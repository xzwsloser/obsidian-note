> 回溯算法的本质其实就是穷举法,回溯算法可以用于解决各种问题
- 回溯算法可以解决的问题如下:
	- 组合问题(`N`个数字里面找出`K`个数字的集合(部分顺序))
	- 切割问题(一个字符串的切割方式)
	- 子集问题(一个集合中有多少个符号要求的子集)
	- 排列问题(`N`个数字按照一定规律进行全排列总共的排列方案种类数)
	- 棋盘问题(比如`N`皇后等)
- 解决回溯算法的问题一定要列举状态图,也就是每一层递归之后选择的元素一定需要列出来
- 回溯算法的模板:
```c++
void backtracking(参数) {
	if(终止条件) {
		存放结果
		return ;
	}

	for(选择下一层的元素) {
		处理节点
		backtracking(路径,目标);
		回溯,撤销选择
	}
}
```
## 组合问题
### 组合中的元素不可以重复 
1. [组合](https://leetcode.cn/problems/combinations/description/) 组合问题的模板题,注意这里需要一个变量来控制但前的层数(也就是当前遍历节点的状态),这里使用一个`Index`进行遍历,`[index + 1 , n]` 表示这一个节点的下一层  代码: [[make_pair1.cpp]] 同时注意利用有效索引范围来进行减枝操作,注意最大有效索引的推导方式,减枝代码如下: [[make_pair2.cpp]] 
2. [组合总和III](https://leetcode.cn/problems/combination-sum-iii/description/)  组合问题,需要一个`startIndex`来控制当前遍历到的行数,另外减枝操作,当当前遍历的`startIndex`向后面循环的时候如果遇到`sum > target`的情况就需要立刻返回(之后的数字都不满足要求了,注意`return`和`continue`的区别)  [[组合问题III.cpp]] 
3. [电话号码的字符组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)  还是一定需要注意递归的层数的表示方式,这里每一层其实就是每一个字符的集合,所以每一层中只需要遍历字符集合即可,所以递归的参数就是需要传入可以代表字符集合的控制量,这就是当前遍历到的索引值,一定需要明确每一层到底遍历的时什么,可以作状态图: [[电话号码的字符组合.cpp]] 
### 组合中的元素可以重复使用
4. [组合总和](https://leetcode.cn/problems/combination-sum/description/) 还是注意此时需要遍历的层数,比如第一层的元素为 `arr[1] , arr[2] , arr[3] ...`,那么下一层的元素就是 `arr[1] , arr[2] , arr[3] ...`,所以需要利用一个标志来控制遍历到的层数,并且开始位置索引为`index`,那么下一层的开始索引也是`index`,  [[组合总和.cpp]] 