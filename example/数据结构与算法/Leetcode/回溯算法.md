> 回溯算法的本质其实就是穷举法,回溯算法可以用于解决各种问题
- 回溯算法可以解决的问题如下:
	- 组合问题(`N`个数字里面找出`K`个数字的集合(部分顺序))
	- 切割问题(一个字符串的切割方式)
	- 子集问题(一个集合中有多少个符号要求的子集)
	- 排列问题(`N`个数字按照一定规律进行全排列总共的排列方案种类数)
	- 棋盘问题(比如`N`皇后等)
- 解决回溯算法的问题一定要列举状态图,也就是每一层递归之后选择的元素一定需要列出来
- 回溯算法的模板:
```c++
void backtracking(参数) {
	if(终止条件) {
		存放结果
		return ;
	}

	for(选择下一层的元素) {
		处理节点
		backtracking(路径,目标);
		回溯,撤销选择
	}
}
```
## 组合问题
1. [组合](https://leetcode.cn/problems/combinations/description/) 组合问题的模板题,注意这里需要一个变量来控制但前的层数(也就是当前遍历节点的状态),这里使用一个`Index`进行遍历,`[index + 1 , n]` 表示这一个节点的下一层  代码: [[make_pair1.cpp]] 同时注意利用有效索引范围来进行减枝操作,注意最大有效索引的推导方式,减枝代码如下: [[make_pair2.cpp]] 
2. [组合总和III](https://leetcode.cn/problems/combination-sum-iii/description/)  组合问题,需要一个`startIndex`来控制当前遍历到的行数,另外减枝操作,当当前遍历的`startIndex`向后面循环的时候如果遇到`sum > target`的情况就需要立刻返回(之后的数字都不满足要求了,注意`return`和`continue`的区别)  [[组合问题III.cpp]] 
3. [电话号码的字符组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)  还是一定需要注意递归的层数的表示方式,这里每一层其实就是每一个字符的集合,所以每一层中只需要遍历字符集合即可,所以递归的参数就是需要传入可以代表字符集合的控制量,这就是当前遍历到的索引值,一定需要明确每一层到底遍历的时什么,可以作状态图: [[电话号码的字符组合.cpp]] 
4. [组合总和](https://leetcode.cn/problems/combination-sum/description/) 还是注意此时需要遍历的层数,比如第一层的元素为 `arr[1] , arr[2] , arr[3] ...`,那么下一层的元素就是 `arr[1] , arr[2] , arr[3] ...`,所以需要利用一个标志来控制遍历到的层数,并且开始位置索引为`index`,那么下一层的开始索引也是`index`,  [[组合总和.cpp]] 
5. [组合总和II](https://leetcode.cn/problems/combination-sum-ii/) 本题目的不同之处在与待取元素的集合中存在重复的元素,但是有要求最终返回的集合中没有重复元素,所以如果直接利用最简单的组合方法,就会导致组合中的元素重复,比如 `[1,7,1] target = 8` 就会造成答案及集合中的元素重复,所以这里使用一个`used`数组来标记数据正在使用,如果一个数字正在使用,表示当前遍历到的数字和原来的数字在同样一个树枝上面,如果`used`的值为`false`,那么说明当前元素和待遍历元素在同一个树层上面需要跳过,同时注意去重:  [[组合总和II.cpp]]  

>组合问题的总结(三类组合问题):
- 最一般的情况: 数组中的元素不重复并且最终要求集合中的元素不重复,比如 `1` `2`  `3`  解决方式: 直接利用一个索引`startIndex`用于控制当前遍历的层数,每一次递归直接传入`curIndex + 1`表示遍历后面的元素即可
- 数组中的元素不重复,但是数组中的每一个元素都可以使用多次,但是最终的集合中不可以出现相同的集合, 解决方法: 此时上面一个树层中的开始元素可以再一次和它自己组合,所以此时需要传递一个`startIndex`控制遍历索引,同时递归的时候传入`curIndex`本身作为下一层的开始的位置即可
- 数组中的元素重复,并且要求最终的组合中没有重复的组合,解决方法: 此时不可以重复使用元素,所以利用一个`used`来标记相同元素的位置,如果`used[i] = false` 表示当前遍历的相同元素和与它相同的元素在同一个树层,此时直接`continue`即可,如果`used[i] = true`,表示当前元素正在使用,所以此时和它相同的元素可以使用
- 另外注意给定元素个数的减枝操作和组合总和的减枝
- 各种情况的状态图如下:
1. 元素不重复并且组合不重复:
![[Pasted image 20241029164636.png]]
2. 元素不重复并且可以无限次使用要求组合不重复
![[Pasted image 20241029164720.png]]
3. 元素重复并且要求组合中的元素不重复(注意`used`数组的含义):
![[Pasted image 20241029164751.png]]
## 分割问题
