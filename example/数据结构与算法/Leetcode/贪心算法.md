d> 贪心算法的核心思想就是由局部最优解推出全局最优解,所以每一次指用考虑局部最优即可,如果要想证明局部最优可以推出全局最优可以使用数学归纳法或者反证法

1. [分发饼干](https://leetcode.cn/problems/assign-cookies/submissions/577994728/) 此时的贪心策略就是尽量把小饼干发放给胃口小的孩子,这样就可以找到局部最优算法,此时只需要利用两个指针,一个指针指向孩子另外一个指针指向饼干,在遍历的过程中不断找到小的饼干喂给孩子即可  [[分发饼干.cpp]] 
2. [摆动序列](https://leetcode.cn/problems/wiggle-subsequence/description/) 可以画图理解,此时局部最优算法就是把单调坡上面的所有数字删除,只是留下局部峰值中的数据,例如此时使用`preDiff`记录前面两个数字的差值,`curDiff`记录当前数字和后面数字的差值,当`preDiff`与`curDiff`异号的时候就表示遇到了局部峰,此时就可以把结果进行自增操作了,但是注意这里的细节比较多,比如:
	- 遇到平坡并且最有一个元素出现峰值的情况,所以此时要想要把记录平坡中的最后一个元素,允许`preDiff = 0`
	- 对于第一个元素,可以默认是一个局部峰(一定包含在最终的结果中,可以证明),所以可以把`preDiff`设置为`0` 从而得到这一个局部峰并且把`result`初始化为`1`表示第一个元素是一个局部峰
	- 对于平坡并且单调的情况,注意此时只有早出现波动的时候才可以更新`preDiff = curDiff`     代码  [[摆动序列.cpp]] 
3. [最大子数组和](https://leetcode.cn/problems/maximum-subarray/) 非常经典的一个题目,贪心策略: 当当前的总和小与`0`的时候还不如从下面一个元素重新开始加,但是注意这里有一个小坑,也就是不可以在当前元素和最大元素进行比较的时候设置`count = 0`,否则就会导致最大值可能为`0`,所以智能在最后把总和设置为 `0`(代码随想录的做法) ,当然也可以直接把总和设置为当前数字并且进行比较也是一样的 [[最大子数组和.cpp]] 
4. [买卖股票的最佳时间II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/) 贪心策略有两种: 
	- 由于利润是累加的,所以可以只要后面一天的利润大于前面一天的利润就可以卖出股票了
	- 或者把数组想象成一个山峰,在谷底买入股票,在山顶卖出股票,但是代码实现可能较为困难
	另外注意写代码的时候不要害怕对于双指针的移动,可以看一个例子,并且根据这一个例子找出指针移动的规律,对于边界条件注意在每一次改变变量的时候添加即可,如果出错大不了直接改   代码: [[买卖股票的最佳时间II.cpp]] 
5. [跳跃游戏](https://leetcode.cn/problems/jump-game/description/) 局部最优: 获取到最大覆盖的索引的位置,每一次不断更新最大索引的位置,并且遍历当前位置到最大索引的所有元素,如果遇到当前元素可以覆盖到数组末尾就可以返回`true`了,当然也可以使用一个范围 `[startIndex,endIndex]` ,每一次计算这一个范围可以到达的下一个索引范围即可   代码:  [[跳跃游戏.cpp]] 
6. [跳跃游戏II](https://leetcode.cn/problems/jump-game-ii/) 此时还是需要基于范围,每一次范围就表示走一步了,还是采用两种方法:
	- 自己自创的方法,范围扩散,每一次利用一个`startIndex`记录当前位置开始的索引,`endIndex`用于记录最大索引范围,每一次遍历这一个范围内的数字并且更新这两个值即可
	- 代码随想录的方法,利用一个变量记录当前可以遍历到的范围,利用一个索引记录下一步可以到达的索引,当走到当前索引的位置的时候就可以更新步数了,更加接近实际   代码 [[跳跃游戏II.cpp]] 
7. [K次去反之后最大化的整数和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/) 这里还是两种贪心的思路: 第一种就是不断找到最小的元素并且把最小的元素反转即可,另外一种思路就是首先按照绝对值排序,对于绝对值大的元素如果小与`0`就可以反转,如果最终反转此时没有使用完毕,就可以堆对这其中某一个元素多次反转,如果最后还剩下一次就可以反转绝对值最小的以一个元素  [[K次取反之后的最大化的整数和.cpp]]
8. [加油站](https://leetcode.cn/problems/gas-station/description/) 三种方法: 暴力解法(写出来了,但是测试用例中二十万个`0` ... ) , 贪心算法:
	- 全局最优: 从`0` 出发计算所有的差值总和,如果得到所有的差值总和大小小与`0`说明不可能找到对应的索引,同时在这一个过程中记录累加值的最小量,之后从后面向前面遍历直到找到可以完全填补`min`的位置就可以返回了(这一个位置一定可以填补最小值)
	- 局部最优: 局部最优的特点就是不断调整策略,所以局部最优的方法就是如果遇到当前的累加值`<0` 说明这一个区间的前面一个区间的任意一个位置开始都不可以(注意此时前面的累积值都是大于`0`的),所以此时需要把当前总和设置为`0`重新开始从新的索引位置开始对于元素执行相加操作   代码: [[加油站.cpp]] 
9. [分发糖果](https://leetcode.cn/problems/candy/)  一道`hard`,解法就是由于这里事物有两面性,所以此时需要考虑左边和右边的情况,考虑右边孩子大于左边孩子的情况从左边向右边遍历,考虑左边孩子大于右边孩子的情况需要从右边向左边遍历,遍历的过程中注意后面一个遍历的过程中每一个孩子糖果数量的确定方式就是只用满足比两边的孩子的糖果数量多即可,所以此时的递归公式为 : `candyVec[i] = max(candyVec[i] , candyVec[i + 1] + 1)`   代码:  [[分发糖果.cpp]] 