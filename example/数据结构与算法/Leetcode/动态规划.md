动态规划解题步骤:
	1. 确定创建的`dp`数组中对应下标元素的含义
	2. 确定递推公式
	3. 利用递推公式画出状态图,利用状态图确定数组的初始化
	4. 确定遍历的方式,比如背包问题中首先遍历背包还是首先遍历物品
## 动态规划例题
1. [斐波那契数](https://leetcode.cn/problems/fibonacci-number/description/)   简单的`dp`    [[斐波那契数.cpp]] 
2. [爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)   注意初始化    [[爬楼梯.cpp]] 
3. [使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)   递推公式:  `dp[i] = min(dp[i - 1] + cost[i - 1] , dp[i - 2] + cost[i - 2])`     [[使用最小花费爬楼梯.cpp]] 
4. [不同路径](https://leetcode.cn/problems/unique-paths/submissions/579106895/)  最基本二维`dp`,递推公式: `dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`   遍历顺序:顺序遍历即可    [[不同路径.cpp]] 
5. [不同路径II](https://leetcode.cn/problems/unique-paths-ii/submissions/579108913/)   此时递推公式还是上面的,但是此时如果周围的位置存在障碍,那么障碍的位置需要初始化为`0`    [[不同路径II.cpp]] 
6. [拆分整数](https://leetcode.cn/problems/integer-break/submissions/579115954/)  这一个题目的递推公式并不是取决于周围的值,而是取决于前面的一切值得,比如对于`n`,如果拆分成两个整数就是`(i - k) * i` , 如果拆分为多个整数那么就是 `dp[i - k] * k`  , 这里的`k` 就是假设除去一个`k` 之外看最大的乘积,注意这里的循环索引最大可以到`i / 2` 这是由于均值不等式,所以尽可能平均分配才可以使得乘积最大,所以这一个数字不可能超过`i / 2`   [[拆分整数.cpp]]  
7. [不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)   注意此时的递归函数又是比较难想,此时需要把不同的节点作为头节点,确定左右子树中节点的个数,从而确定总共的方案数量,比如对于`n`个节点的树木,当使用`j`作为头接电脑的时候,左子树中的索引范围为`1 - j - 1` , 右子树的范围为 `j + 1 - n`  所以此时需要加上 `dp[j - 1] * dp[n - j]`    [[不同的二叉搜索树.cpp]] 
8. `01`背包系列(背包的容量有限并且每一个物品只有两种状态: 取或者不取): 
	1. [01背包二维数组](https://kamacoder.com/problempage.php?pid=1046)  注意这一个问题很重要,这里`dp[i][j]` 的含义就是在索引为范围为`[0,i]`内的元素中任意选取元素并且背包容量为`j` 此时可以获得的最大价值 , 递推公式: 当背包容量无法容纳`weight[i]` 的时候就延续之前的`dp[i - 1][j]` 如果可以容纳`weight[i]`那么就选取是否装下第`i`个元素中最大的一个值,也就是:   `dp[i][j] = max(dp[i - 1][j] , dp[i - 1][j - weight[i]] + value[i])`    [[01背包二维数组.cpp]]    
	2. [01背包滚动数组](https://kamacoder.com/problempage.php?pid=1046)  观察上面的递推公式,发现只是利用`i`来控制索引,所以可以把二维数组压缩为一维数组,`dp[j]` 表示背包容量为`j`的时候可以容纳的最大价值,初始化只需要把所有位置初始化为`0`即可,只是由于第一次遍历的时候不需要之前的状态(也就是没有物品的时候价值一定是`0`) ,另外在遍历的过程中,注意外层循环遍历物品,表示控制层数,内层循环遍历背包表示控制背包容量,需要从后面向前面遍历,这是由于遍历的过程中需要使用前面的数据这这里是为了放置覆盖前面的数据,递推公式: `dp[j] = max(dp[j] , dp[j - weight[i]] + value[i])`    [[01背包滚动数组.cpp]] 
9. [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)  典型的`01`背包问题,首先把背包容量设置为`sum / 2`,之后判断背包所有元素的和是否等于背包容量即可,这里注意`weight`和`value`是一致的,都是表示数值大小,递推公式: `dp[j] = max(dp[j] , dp[j - nums[i]) + nums[i])`        [[分割等和子集.cpp]] 
10. [最后一块石头的重量II](https://leetcode.cn/problems/last-stone-weight-ii/description/)   简单思考一下,粉碎之前两块是否的重量为`y + x`,粉碎之后两块石头的重量为`y - x`, 此时重量的差值为`2*x`,所以此时只需要令背包的容量为`sum / 2` , 求出背包的最大可以容纳的石头重量即可,最后答案就是 `sum - 2*dp[sum / 2]`  ,递推公式同上: [[最后一块石头的重量II.cpp]]   
- `01`背包总结,`01` 背包的基本问题:  有`m`中物品,每一种物品的重量为`weight[i]`,价值为`value[i]`  , 背包容量为`n` , 求解背包中可以装下的物品的最大值,这里的一个基本思路就是对于第`i`个物品分为两种情况讨论(也就是是否需要装这一个物品),从而就可以确定递推公式了,两种表现形式如下:
	- 二维数组: `dp[i][j]` 表示任意选取索引范围为`[0,i]`的物品装入到背包容量为`j` 的背包可以获得的最大价值,遍历方式: 顺序遍历即可(注意此时如果无法装载第`i`样物品就直接继承之前即可)
	- 滚动数组: `dp[j]`  表示背包为`j`的物品在第`i`层可以装载物品的最大价值,遍历方式: 首先遍历物品,之后遍历容量并且需要倒序遍历容量(为了放置覆盖上一层在本层中需要使用的值)
- `01`背包的用途除了处理传统的背包问题,还可以用于处理给定一个最大值,求解通过装载一定元素到达距离这一个最大值最近点的值
