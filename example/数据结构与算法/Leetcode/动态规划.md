动态规划解题步骤:
	1. 确定创建的`dp`数组中对应下标元素的含义
	2. 确定递推公式
	3. 利用递推公式画出状态图,利用状态图确定数组的初始化
	4. 确定遍历的方式,比如背包问题中首先遍历背包还是首先遍历物品
## 动态规划例题
1. [斐波那契数](https://leetcode.cn/problems/fibonacci-number/description/)   简单的`dp`    [[斐波那契数.cpp]] 
2. [爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)   注意初始化    [[爬楼梯.cpp]] 
3. [使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)   递推公式:  `dp[i] = min(dp[i - 1] + cost[i - 1] , dp[i - 2] + cost[i - 2])`     [[使用最小花费爬楼梯.cpp]] 
4. [不同路径](https://leetcode.cn/problems/unique-paths/submissions/579106895/)  最基本二维`dp`,递推公式: `dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`   遍历顺序:顺序遍历即可    [[不同路径.cpp]] 
5. [不同路径II](https://leetcode.cn/problems/unique-paths-ii/submissions/579108913/)   此时递推公式还是上面的,但是此时如果周围的位置存在障碍,那么障碍的位置需要初始化为`0`    [[不同路径II.cpp]] 
6. [拆分整数](https://leetcode.cn/problems/integer-break/submissions/579115954/)  这一个题目的递推公式并不是取决于周围的值,而是取决于前面的一切值得,比如对于`n`,如果拆分成两个整数就是`(i - k) * i` , 如果拆分为多个整数那么就是 `dp[i - k] * k`  , 这里的`k` 就是假设除去一个`k` 之外看最大的乘积,注意这里的循环索引最大可以到`i / 2` 这是由于均值不等式,所以尽可能平均分配才可以使得乘积最大,所以这一个数字不可能超过`i / 2`   [[拆分整数.cpp]] 