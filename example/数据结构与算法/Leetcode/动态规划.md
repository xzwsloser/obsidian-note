cle动态规划解题步骤:
	1. 确定创建的`dp`数组中对应下标元素的含义
	2. 确定递推公式
	3. 利用递推公式画出状态图,利用状态图确定数组的初始化
	4. 确定遍历的方式,比如背包问题中首先遍历背包还是首先遍历物品
## 动态规划例题
1. [斐波那契数](https://leetcode.cn/problems/fibonacci-number/description/)   简单的`dp`    [[斐波那契数.cpp]] 
2. [爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)   注意初始化    [[爬楼梯.cpp]] 
3. [使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)   递推公式:  `dp[i] = min(dp[i - 1] + cost[i - 1] , dp[i - 2] + cost[i - 2])`     [[使用最小花费爬楼梯.cpp]] 
4. [不同路径](https://leetcode.cn/problems/unique-paths/submissions/579106895/)  最基本二维`dp`,递推公式: `dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`   遍历顺序:顺序遍历即可    [[不同路径.cpp]] 
5. [不同路径II](https://leetcode.cn/problems/unique-paths-ii/submissions/579108913/)   此时递推公式还是上面的,但是此时如果周围的位置存在障碍,那么障碍的位置需要初始化为`0`    [[不同路径II.cpp]] 
6. [拆分整数](https://leetcode.cn/problems/integer-break/submissions/579115954/)  这一个题目的递推公式并不是取决于周围的值,而是取决于前面的一切值得,比如对于`n`,如果拆分成两个整数就是`(i - k) * i` , 如果拆分为多个整数那么就是 `dp[i - k] * k`  , 这里的`k` 就是假设除去一个`k` 之外看最大的乘积,注意这里的循环索引最大可以到`i / 2` 这是由于均值不等式,所以尽可能平均分配才可以使得乘积最大,所以这一个数字不可能超过`i / 2`   [[拆分整数.cpp]]  
7. [不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)   注意此时的递归函数又是比较难想,此时需要把不同的节点作为头节点,确定左右子树中节点的个数,从而确定总共的方案数量,比如对于`n`个节点的树木,当使用`j`作为头接电脑的时候,左子树中的索引范围为`1 - j - 1` , 右子树的范围为 `j + 1 - n`  所以此时需要加上 `dp[j - 1] * dp[n - j]`    [[不同的二叉搜索树.cpp]] 
8. `01`背包系列(背包的容量有限并且每一个物品只有两种状态: 取或者不取): 
	1. [01背包二维数组](https://kamacoder.com/problempage.php?pid=1046)  注意这一个问题很重要,这里`dp[i][j]` 的含义就是在索引为范围为`[0,i]`内的元素中任意选取元素并且背包容量为`j` 此时可以获得的最大价值 , 递推公式: 当背包容量无法容纳`weight[i]` 的时候就延续之前的`dp[i - 1][j]` 如果可以容纳`weight[i]`那么就选取是否装下第`i`个元素中最大的一个值,也就是:   `dp[i][j] = max(dp[i - 1][j] , dp[i - 1][j - weight[i]] + value[i])`    [[01背包二维数组.cpp]]    
	2. [01背包滚动数组](https://kamacoder.com/problempage.php?pid=1046)  观察上面的递推公式,发现只是利用`i`来控制索引,所以可以把二维数组压缩为一维数组,`dp[j]` 表示背包容量为`j`的时候可以容纳的最大价值,初始化只需要把所有位置初始化为`0`即可,只是由于第一次遍历的时候不需要之前的状态(也就是没有物品的时候价值一定是`0`) ,另外在遍历的过程中,注意外层循环遍历物品,表示控制层数,内层循环遍历背包表示控制背包容量,需要从后面向前面遍历,这是由于遍历的过程中需要使用前面的数据这这里是为了放置覆盖前面的数据,递推公式: `dp[j] = max(dp[j] , dp[j - weight[i]] + value[i])`    [[01背包滚动数组.cpp]] 
9. [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)  典型的`01`背包问题,首先把背包容量设置为`sum / 2`,之后判断背包所有元素的和是否等于背包容量即可,这里注意`weight`和`value`是一致的,都是表示数值大小,递推公式: `dp[j] = max(dp[j] , dp[j - nums[i]) + nums[i])`        [[分割等和子集.cpp]] 
10. [最后一块石头的重量II](https://leetcode.cn/problems/last-stone-weight-ii/description/)   简单思考一下,粉碎之前两块是否的重量为`y + x`,粉碎之后两块石头的重量为`y - x`, 此时重量的差值为`2*x`,所以此时只需要令背包的容量为`sum / 2` , 求出背包的最大可以容纳的石头重量即可,最后答案就是 `sum - 2*dp[sum / 2]`  ,递推公式同上: [[最后一块石头的重量II.cpp]]   
- `01`背包总结,`01` 背包的基本问题:  有`m`中物品,每一种物品的重量为`weight[i]`,价值为`value[i]`  , 背包容量为`n` , 求解背包中可以装下的物品的最大值,这里的一个基本思路就是对于第`i`个物品分为两种情况讨论(也就是是否需要装这一个物品),从而就可以确定递推公式了,两种表现形式如下:
	- 二维数组: `dp[i][j]` 表示任意选取索引范围为`[0,i]`的物品装入到背包容量为`j` 的背包可以获得的最大价值,遍历方式: 顺序遍历即可(注意此时如果无法装载第`i`样物品就直接继承之前即可)
	- 滚动数组: `dp[j]`  表示背包为`j`的物品在第`i`层可以装载物品的最大价值,遍历方式: 首先遍历物品,之后遍历容量并且需要倒序遍历容量(为了放置覆盖上一层在本层中需要使用的值)
- `01`背包的用途除了处理传统的背包问题,还可以用于处理给定一个最大值,求解通过装载一定元素到达距离这一个最大值最近点的值
11. [目标和](https://leetcode.cn/problems/target-sum/description/)  类似于上面的题目,也就是对于求和的题目都应该想到背包问题(背包问题的重点就在于是否放入第`i`中物品),但是主要这里的递推公式: `dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]`   注意在列初始化的时候如何找到和为 `0` 的情况,也就是确定和为`0` 的总共情况数量
12. [一和零](https://leetcode.cn/problems/ones-and-zeroes/description/)   注意`01`背包的思想就在与是否去除第`i`个元素,滚动数组和多维数组的方法都是一样的,这里就是多维情况下的`01`背包问题 , 注意使用三位数组的初始化方式:   [[一和零.cpp]] 
- 背包问题的种类:
![[Pasted image 20241110142115.png]]
- 完全背包问题: 和`01`背包问题不同的地方就在于完全背包问题中元素可以去取出无数次,所以相对于`01`背包问题利用滚动数组的时候,遍历第二层的时候就需要注意,此时应该正序遍历,就是为了后面可以用到前面的结果,比如也就是遍历到`(i,j)` 的时候就是需要把`i`装入到背包中,从后面向前面遍历,前面的没有改变(也就是没有装下`i`) ,但是从前面向后面遍历,前面的元素已经装下`i`了,后面的元素可以重复装 ,只是遍历顺序不同     [[完全背包.cpp]]   
13. [零钱兑换II](https://leetcode.cn/problems/coin-change-ii/)  完全背包问题,还是分为第`i`个物品是否装入到背包中,递推公式: `dp[j] += dp[j - coins[i]]`  , 但是注意测试用例中有超过`int`的版本,所以需要使用比较大的无符号整型变量 , 所以需要使用`uint64_t`   [[零钱兑换 1.cpp]] 
14. [组合总和IV](https://leetcode.cn/problems/combination-sum-iv/submissions/579861778/)  注意对于完全背包问题:
	- 如果需要求解组合数,那么就需要外层遍历物品,内层遍历背包容量
	- 如果要求求解排列数,那么就需要外层遍历背包容量,内层遍历物品    [[组合总和IV.cpp]] 
15. [爬楼梯(进阶版)](https://kamacoder.com/problempage.php?pid=1067)  两种思路:   [[爬楼梯(进阶版).cpp]] 
	- 抽象为背包问题: 注意此时需要求解的是排列数,所以需要首先遍历容量之后遍历背包,递推公式为: `dp[i] += dp[i - j]` 
	- 不抽象为背包问题: 此时的递归公式为:  
$$
dp[i] = \sum\limits_{k = i - m}^{i - 1} dp[k] 
$$
16.  [零钱兑换](https://leetcode.cn/problems/coin-change/submissions/579944923/)   递推公式: `dp[j] = min(dp[j] , dp[j - coins[i]] + 1)`  注意此时需要注意初始化方式: `dp[0] = 0 , dp[j] = INT_MAX` ,当元素为`INT_MAX`的时候就表示没有初始化,没有满足要求的组合    [[零钱兑换 1.cpp]] 
17. [完全平方数](https://leetcode.cn/problems/perfect-squares/)  和上面的题目一个样,只不过这里的目标数组可以看成: `dp[i] = i*i`    [[完全平方数字.cpp]] 
18. [单词拆分](https://leetcode.cn/problems/word-break/description/)  比较难想,注意此时只需要考虑`s`,只需要把`s`划分为不懂得段并且在字典中寻找对应的元素即可  , `dp[j]`  表示长度为`j`的从头开始的子字符串是否可以由字典中的元素组成,递推公式: `if(us.find(s.substr(j , i - j)) != us.end() && dp[j]) dp[i] = true` 注意此时由于需要求解排列数,所以需要首先遍历背包(也就是`dp`),之后遍历元素,也就是 `i`之前的元素  (元素是子串,背包是字符串)  [[单词拆分.cpp]]  
19. [多重背包问题](https://kamacoder.com/problempage.php?pid=1066)  特征就是一个物品可以使用有限次数,解决方法就是把可以使用有限次数的物品拆分为可以使用次数个物品数量,从而转换为`01`背包问题,注意`01`背包问题中是顺序遍历物品的,所以只需要每一次在内层循环中遍历多次物品(也就是在有限次数下遍历物品)即可       [[多重背包.cpp]] 
- 背包问题总结:
	- 背包问题的特点如下:
		- `01`背包: 每一物品只可以使用一次
		- 完全背包: 每一个物品可以使用多次
		- 多重背包: 每一物品可以使用有限次
	- 背包问题解决方法:
		- `01`背包利用二维数组或者滚动数组,注意利用滚动数组的时候需要内层反序遍历背包容量,外层遍历物品
		- 完全背包利用滚动数组,但是注意遍历背包和遍历物品的顺序,并且遍历背包容量的过程总是从左到右的(比如从`weight[i]`  到`s.size()`) ,注意遍历顺序:
				- 如果是组合数,外层遍历物品,内层遍历背包
				- 如果是排列数,外层遍历背包,内层遍历物品(注意条件判断)
		- 多重背包问题: 把物品的使用此时看成新的各种物品从而把问题转换为`01`背包的问题即可
- 注意背包问题的精髓在与递推公式: `dp[j] = max(dp[j] , dp[j - weight[i]] + value[i])`   递推公式表明的是第`i`件物品时候选取
20. [打家劫舍](https://leetcode.cn/problems/house-robber/submissions/580376479/)    还是类似于背包问题,就在于是否需要取出第`i`个元素,递推公式: `dp[i] = max(dp[i - 1] , dp[i - 2] + nums[i])`  ,需要初始化前面两个元素   [[打家劫舍.cpp]] 
21. [打家劫舍II](https://leetcode.cn/problems/house-robber-ii/) 考虑两种情况: 偷第一家,不偷第一家两种情况,可以利用一个数组`dp[i][2]` 表示相应的情况,`dp[i][0]` 表示不偷第一家的情况,`dp[i][1]` 表示偷第一家的情况,注意初始化方式即可    [[打家劫舍II.cpp]] 
22. [打家劫舍III](https://leetcode.cn/problems/house-robber-iii/)   每一个根节点有两种情况,偷或者没有被偷,所以需要分别讨论这两种情况,所以可以使用一个`vector<int>`数字表示这两种情况: `dp[1]` 表示节点被偷,`dp[0]` 表示节点没有被偷走  [[打家劫舍III.cpp]] 