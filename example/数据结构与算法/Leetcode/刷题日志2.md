# 5.11
> 主要是刷前几天的每日一题

1. [到达最后一个房间的最少时间I](https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-i/description/?envType=daily-question&envId=2025-05-07)  由于 `Leetcode` 上面这一种最短路问题间的很少,所以没有反应过来可以使用 `Dijkstra` 算法,算法的步骤为:  1. 选取距离源点最近的点作为下一个点  2. 利用当前点的位置来更新其他点到源点的最小记录,更新 `minDist` 数组   , 同时为了避免重复情况,需要对于当前节点进行判断,也就是当当前节点目前距离源点的距离没有被更新那么直接下一个(其实也可以使用一个 `visited` 数组来记录当前点是否被浏览过) (ls 的写法更好 !)
2. [到达最后一个房间的最少时间 II](https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-ii/) 和前面一样,只是注意判断的方式(不需要存储访问次数) , 只需要判断 (`curx + cury % 2` 即可,有一点类似于高中的路径条数问题)

3. [统计平衡数组的数量](https://leetcode.cn/problems/count-number-of-balanced-permutations/description/?envType=daily-question&envId=2025-05-09)  `2600` 分题目,放了
4. [数组的最小和](https://leetcode.cn/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/description/?envType=daily-question&envId=2025-05-10) 贪心算法,只需要比较 `sum1 + cnt1` , `sum2 + cnt2` 的大小,小的一个位置进行补偿即可,如果 `0` 的数量为 `0` 可能返回 `-1`
5. 连续奇数: 定长滑动窗口
