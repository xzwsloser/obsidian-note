# 5.11
> 主要是刷前几天的每日一题

1. [到达最后一个房间的最少时间I](https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-i/description/?envType=daily-question&envId=2025-05-07)  由于 `Leetcode` 上面这一种最短路问题间的很少,所以没有反应过来可以使用 `Dijkstra` 算法,算法的步骤为:  1. 选取距离源点最近的点作为下一个点  2. 利用当前点的位置来更新其他点到源点的最小记录,更新 `minDist` 数组   , 同时为了避免重复情况,需要对于当前节点进行判断,也就是当当前节点目前距离源点的距离没有被更新那么直接下一个(其实也可以使用一个 `visited` 数组来记录当前点是否被浏览过) (ls 的写法更好 !)
2. [到达最后一个房间的最少时间 II](https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-ii/) 和前面一样,只是注意判断的方式(不需要存储访问次数) , 只需要判断 (`curx + cury % 2` 即可,有一点类似于高中的路径条数问题)

3. [统计平衡数组的数量](https://leetcode.cn/problems/count-number-of-balanced-permutations/description/?envType=daily-question&envId=2025-05-09)  `2600` 分题目,放了
4. [数组的最小和](https://leetcode.cn/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/description/?envType=daily-question&envId=2025-05-10) 贪心算法,只需要比较 `sum1 + cnt1` , `sum2 + cnt2` 的大小,小的一个位置进行补偿即可,如果 `0` 的数量为 `0` 可能返回 `-1`
5. 连续奇数: 定长滑动窗口
# 5.12
1. [找出三位偶数](https://leetcode.cn/problems/finding-3-digit-even-numbers/description/?envType=daily-question&envId=2025-05-12) 经典的全排列去重 , 不需要控制索引的位置,使用 `used` 数组标记当前数字是否访问过,同一个树枝可以重复访问同一个数字,但是同一个数层不可以重复访问
# 5.3
1. [字符串转换之后的长度](https://leetcode.cn/problems/total-characters-in-string-after-transformations-i/solutions/2967070/di-tui-by-tsreaper-j54j/?envType=daily-question&envId=2025-05-13) 记忆化搜索即可 , 或者使用动态规划也可以 , 如果使用记忆化搜索只需要记录 `t` 即可,这是由于 `t - (z - c + 1)` 次数相同那么答案就相同(或许还可以优化)
![[Pasted image 20250513091122.png]]
2. [重新安排空闲空间II](https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-i/) 注意转换为定长滑动窗口问题,定长滑动窗口的作用(求解区间最大值,统计区间内满足条件的元素,求解"最多"问题),定长滑动窗口的一般步骤如下:
```c++
for (int i = 0 ; i <= n ; i ++) {
	// 1. 元素进入窗口
	s += get(i);
	// 2. 判断窗口大小
	if (i < k) {
		continue;	
	}
	// 3. 更新答案
	ans = max(ans , s);
	// 4. 离开窗口
	s -= get(i - k);	
}
```
当然也有其他的方法可以写
